# ------------------------------------------------------------- #
#  Name: Nuke Text Editor ####################################  #
# ############################################################  #
# ------------------------------------------------------------- #
#  DESCRIPTION: ##############################################  #
# ------------------------------------------------------------- #
#  Nuke Text Editor is a custom text editor panel for Nuke.     #
#  It allows users to create, open, edit and save text files,   #
#  manage notes and task lists, and format text directly inside #
#  Nuke using a dark, compact interface.                        #
# --- Customization Notes ---                                   #
# This file contains application logic with safe points for     #
# modification.                                                 #
#                                                               #
#  Main features:                                               #
#    - Rich text formatting (font, size, bold/italic/underline, #
#      color, highlight, alignment).                            #
#    - File browser sidebar for navigating folders and files.   #
#    - New/Open/Save/Save As and Recent Files.                  #
#    - Find / Replace dialog.                                   #
#    - Word and character counter.                              #
#    - About dialog with author and GitHub link.                #
#    - Tabs: multiple documents open in one window.             #
#    - Advanced tab controls (context menu, middle-click,       #
#      drag-reorder, inline "+" tab like Notepad).              #
#    - Medium-level syntax highlighting per extension, using    #
#      Python's 're' (works in PySide2 and PySide6).            #
#    - v8: Advanced VSCode-style gutter with line numbers and   #
#      simple indent-based code folding markers.                #
# ------------------------------------------------------------- #

import nuke
import nukescripts
import os
import io
import re
import json
import uuid
import hashlib
import time
import datetime

try:
    # Prefer PySide2 when available
    from PySide2 import QtCore, QtGui, QtWidgets
except ImportError:
    # Fall back to PySide6 if PySide2 is not available
    from PySide6 import QtCore, QtGui, QtWidgets

from FileBrowser import FileBrowser  # External file browser widget

_text_editor_instance = None  # Global instance handle


# ------------------------------------------------------------- #
#  Extension -> language mapping for syntax highlight           #
# ------------------------------------------------------------- #
EXTENSION_LANGUAGE = {
    ".py":   "python",
    ".json": "json",
    ".md":   "markdown",
    ".mkd":  "markdown",
    ".markdown": "markdown",
    ".nk":   "nuke",
    ".ini":  "ini",
    ".cfg":  "ini",
    ".html": "html",
    ".htm":  "html",
    ".xml":  "html",
    ".js":   "javascript",
    ".ts":   "javascript",
    ".css":  "css",
    ".c":    "c_like",
    ".h":    "c_like",
    ".cpp":  "c_like",
    ".hpp":  "c_like",
    ".java": "c_like",
    ".sh":   "bash",
    ".bat":  "batch",
    ".cmd":  "batch",
}


# Minimap / indent guide configuration
MINIMAP_WIDTH = 0  # minimap disabled; kept for compatibility
INDENT_TAB_SIZE = 4  # spaces per indent level

# File-type colors for tabs
FILETYPE_TAB_COLORS = {
    "python": QtGui.QColor("#50fa7b"),
    "json": QtGui.QColor("#8be9fd"),
    "markdown": QtGui.QColor("#ff79c6"),
    "nuke": QtGui.QColor("#bd93f9"),
    "ini": QtGui.QColor("#f1fa8c"),
    "html": QtGui.QColor("#ffb86c"),
    "javascript": QtGui.QColor("#f1fa8c"),
    "css": QtGui.QColor("#8be9fd"),
    "c_like": QtGui.QColor("#ffb86c"),
    "bash": QtGui.QColor("#50fa7b"),
    "batch": QtGui.QColor("#50fa7b"),
    "text": QtGui.QColor("#bbbbbb"),
}

# ------------------------------------------------------------- #
#  Simple, Nuke-safe syntax highlighter                         #
# ------------------------------------------------------------- #
class SimpleHighlighter(QtGui.QSyntaxHighlighter):
    """
    Medium-level, Nuke-safe syntax highlighter.

    - Uses Python's 're' module instead of Qt's QRegExp / QRegularExpression,
      so it works in both PySide2 and PySide6.
    - Does NOT touch the base text color (inherits QTextEdit color).
    - Adds colors only on top of existing text (keywords, strings, etc.).
    """

    def __init__(self, document):
        """Autogenerated stub documentation removed for clarity."""
        # Call Qt base class directly to avoid super() issues inside Nuke.
        QtGui.QSyntaxHighlighter.__init__(self, document)
        self.language = "text"
        self.rules = []
        self._build_rules("text")

    def set_language(self, language):
        """Change language and rebuild highlighting rules."""
        lang = (language or "text").lower()
        if lang == self.language and self.rules:
            return
        self.language = lang
        self._build_rules(lang)
        self.rehighlight()

    def _build_rules(self, lang):
        """Autogenerated stub documentation removed for clarity."""
        self.rules = []  # list of (compiled_regex, QTextCharFormat)

        # Helper to add a rule (pattern, format)
        def add(pattern, color_hex, bold=False, italic=False):
            """Autogenerated stub documentation removed for clarity."""
            fmt = QtGui.QTextCharFormat()
            fmt.setForeground(QtGui.QColor(color_hex))
            if bold:
                fmt.setFontWeight(QtGui.QFont.Bold)
            if italic:
                fmt.setFontItalic(True)
            regex = re.compile(pattern)
            self.rules.append((regex, fmt))

        # ---------- Python ----------
        if lang == "python":
            keywords = [
                "and", "as", "assert", "break", "class", "continue", "def",
                "del", "elif", "else", "except", "False", "finally", "for",
                "from", "global", "if", "import", "in", "is", "lambda",
                "None", "nonlocal", "not", "or", "pass", "raise", "return",
                "True", "try", "while", "with", "yield",
            ]
            add(r"\b(" + "|".join(keywords) + r")\b", "#ff79c6", bold=True)   # keywords
            add(r"#.*$", "#6272a4", italic=True)                             # comments
            add(r"'[^'\\]*'", "#f1fa8c")                                     # single-quoted strings
            add(r'"[^"\\]*"', "#f1fa8c")                                     # double-quoted strings
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers
            add(r"\b[A-Za-z_][A-Za-z0-9_]*(?=\()", "#50fa7b")                # function calls

        # ---------- JSON ----------
        elif lang == "json":
            add(r'"[^"\\]*"\s*:', "#8be9fd", bold=True)                      # keys
            add(r'"[^"\\]*"', "#f1fa8c")                                     # string values
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers
            add(r"\b(true|false|null)\b", "#bd93f9", bold=True)              # booleans/null

        # ---------- Markdown ----------
        elif lang == "markdown":
            add(r"^#{1,6}.*$", "#ff79c6", bold=True)                         # headings
            add(r"\*\*[^*]+\*\*", "#f1fa8c", bold=True)                      # bold
            add(r"\*[^*]+\*", "#bd93f9", italic=True)                        # italic
            add(r"`[^`]+`", "#bd93f9")                                       # inline code
            add(r"\[[^\]]+\]\([^)]+\)", "#8be9fd")                           # links

        # ---------- Nuke .nk ----------
        elif lang == "nuke":
            nk_keywords = [
                "push", "pop", "set", "add_layer", "inputs", "version",
                "addUserKnob", "Animated", "Group", "Root", "Viewer",
            ]
            add(r"\b(" + "|".join(nk_keywords) + r")\b", "#ff79c6", bold=True)
            add(r'"[^"\\]*"', "#f1fa8c")                                     # strings
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers
            add(r"#.*$", "#6272a4", italic=True)                             # comments

        # ---------- INI / CFG ----------
        elif lang == "ini":
            add(r"^\[[^\]]+\]", "#ff79c6", bold=True)                        # [section]
            add(r"^[A-Za-z0-9_.]+(?=\s*=)", "#8be9fd")                       # key names
            add(r"^[;#].*$", "#6272a4", italic=True)                         # comments
            add(r'"[^"\\]*"', "#f1fa8c")                                     # string values
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers

        # ---------- HTML / XML ----------
        elif lang == "html":
            add(r"</?[A-Za-z_][A-Za-z0-9_\-]*", "#ff79c6", bold=True)        # tags
            add(r"\b[A-Za-z_:][A-Za-z0-9_\-:]*=", "#8be9fd")                 # attributes
            add(r'"[^"\\]*"', "#f1fa8c")                                     # attribute values
            add(r"<!--[^>]*-->", "#6272a4", italic=True)                     # comments

        # ---------- JavaScript / TS ----------
        elif lang == "javascript":
            js_keywords = [
                "var", "let", "const", "function", "return", "if", "else",
                "for", "while", "do", "switch", "case", "break", "continue",
                "new", "this", "class", "extends", "super", "import", "from",
                "export", "default", "true", "false", "null", "undefined",
            ]
            add(r"\b(" + "|".join(js_keywords) + r")\b", "#ff79c6", bold=True)
            add(r"\b[A-Za-z_][A-Za-z0-9_]*(?=\()", "#50fa7b")                # function calls
            add(r"'[^'\\]*'", "#f1fa8c")                                     # strings
            add(r'"[^"\\]*"', "#f1fa8c")
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers
            add(r"//.*$", "#6272a4", italic=True)                            # comments

        # ---------- CSS ----------
        elif lang == "css":
            add(r"\.[A-Za-z0-9_\-]+", "#8be9fd")                             # .class
            add(r"#[A-Za-z0-9_\-]+", "#8be9fd")                              # #id
            add(r"\b[A-Za-z\-]+(?=\s*:)", "#ff79c6")                         # properties
            add(r":[^;]+;", "#f1fa8c")                                       # values
            add(r"/\*.*\*/", "#6272a4", italic=True)                         # comments

        # ---------- C / C++ / Java ----------
        elif lang == "c_like":
            c_keywords = [
                "auto", "break", "case", "char", "const", "continue", "default",
                "do", "double", "else", "enum", "extern", "float", "for", "goto",
                "if", "inline", "int", "long", "register", "return", "short",
                "signed", "sizeof", "static", "struct", "switch", "typedef",
                "union", "unsigned", "void", "volatile", "while", "class",
                "public", "private", "protected", "virtual", "template",
                "typename", "namespace", "using",
            ]
            add(r"\b(" + "|".join(c_keywords) + r")\b", "#ff79c6", bold=True)
            add(r"\b[A-Za-z_][A-Za-z0-9_]*(?=\()", "#50fa7b")                # function calls
            add(r"'[^'\\]*'", "#f1fa8c")                                     # strings
            add(r'"[^"\\]*"', "#f1fa8c")
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers
            add(r"//.*$", "#6272a4", italic=True)                            # comments
            add(r"/\*.*\*/", "#6272a4", italic=True)                         # inline block comments

        # ---------- Bash ----------
        elif lang == "bash":
            add(r"^#!.*bash.*$", "#6272a4", italic=True)                     # shebang
            add(r"#.*$", "#6272a4", italic=True)                             # comments
            add(r"\b(if|then|else|fi|for|in|do|done|case|esac|function|return)\b",
                "#ff79c6", bold=True)
            add(r"\$[A-Za-z_][A-Za-z0-9_]*", "#8be9fd")                      # variables
            add(r"'[^']*'", "#f1fa8c")                                       # strings
            add(r'"[^"\\]*"', "#f1fa8c")
            add(r"\b[0-9]+(\.[0-9]+)?\b", "#bd93f9")                         # numbers

        # ---------- Batch (.bat, .cmd) ----------
        elif lang == "batch":
            add(r"^@?echo\s+(on|off)", "#ff79c6", bold=True)
            add(r"\b(if|else|for|in|do|goto|call|set|echo|exit)\b",
                "#ff79c6", bold=True)
            add(r"REM.*$", "#6272a4", italic=True)
            add(r"%[A-Za-z_][A-Za-z0-9_]*%", "#8be9fd")                      # variables

        # ---------- Default / plain text ----------
        else:
            # No extra rules: text will use editor's default color
            self.rules = []

    def highlightBlock(self, text):
        """Apply syntax rules on top of the editor's default text color."""
        if not self.rules:
            return
        for regex, text_format in self.rules:
            for match in regex.finditer(text):
                start = match.start()
                end = match.end()
                if end <= start:
                    continue
                length = end - start
                self.setFormat(start, length, text_format)


# ------------------------------------------------------------- #
#  Persistent TextEdit (keeps formatting on new lines)          #
# ------------------------------------------------------------- #
class PersistentTextEdit(QtWidgets.QTextEdit):
    """
    QTextEdit subclass that preserves the current character format
    when pressing Enter and emits 'emptied' when the document
    becomes completely empty.
    """
    emptied = QtCore.Signal()

    def __init__(self, parent=None):
        """Autogenerated stub documentation removed for clarity."""
        super(PersistentTextEdit, self).__init__(parent)
        # Per-tab metadata
        self.file_path = None
        self.is_modified = False
        self.autosave_id = uuid.uuid4().hex
        # Syntax highlighter attached to this editor
        self.highlighter = SimpleHighlighter(self.document())
        # Placeholder (watermark) text shown when the document is empty.
        # Implemented here (instead of QTextEdit.setPlaceholderText) to ensure
        # consistent behavior across PySide2/PySide6 and Nuke builds.
        self._placeholder_text = ""
        self._placeholder_color = QtGui.QColor("#666666")
        self._placeholder_padding = 8

    def set_placeholder(self, text):
        """Set the watermark text displayed when the editor is empty."""
        self._placeholder_text = text or ""
        self.viewport().update()

    def set_placeholder_color(self, color):
        """Set placeholder text color. Accepts QColor or hex string."""
        try:
            if isinstance(color, QtGui.QColor):
                self._placeholder_color = color
            else:
                self._placeholder_color = QtGui.QColor(str(color))
        except Exception:
            self._placeholder_color = QtGui.QColor("#666666")
        self.viewport().update()

    def paintEvent(self, event):
        """Draw normal QTextEdit, then draw placeholder when empty."""
        super(PersistentTextEdit, self).paintEvent(event)

        if not getattr(self, "_placeholder_text", ""):
            return
        # Only show when empty (ignore whitespace) and no selection composing.
        try:
            empty = (self.toPlainText().strip() == "")
        except Exception:
            empty = True
        if not empty:
            return

        painter = QtGui.QPainter(self.viewport())
        try:
            painter.setPen(self._placeholder_color)
            # Slightly italic to differentiate from real content
            f = QtGui.QFont(self.font())
            f.setItalic(True)
            painter.setFont(f)

            pad = getattr(self, "_placeholder_padding", 8)
            rect = self.viewport().rect().adjusted(pad, pad, -pad, -pad)
            painter.drawText(
                rect,
                QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop | QtCore.Qt.TextWordWrap,
                self._placeholder_text
            )
        finally:
            painter.end()


    def keyPressEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        # Preserve formatting when inserting a new line
        if event.key() in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
            cursor = self.textCursor()
            fmt = cursor.charFormat()
            super(PersistentTextEdit, self).keyPressEvent(event)
            cursor = self.textCursor()
            cursor.mergeCharFormat(fmt)
            self.mergeCurrentCharFormat(fmt)
        else:
            super(PersistentTextEdit, self).keyPressEvent(event)

        # Emit 'emptied' when text is cleared
        if self.toPlainText().strip() == "":
            self.emptied.emit()


# ------------------------------------------------------------- #
#  Advanced VSCode-like line-number gutter + folding            #
# ------------------------------------------------------------- #

class LineNumberArea(QtWidgets.QWidget):
    """Narrow gutter widget that paints line numbers and fold markers."""
    def __init__(self, editor):
        super(LineNumberArea, self).__init__(editor)
        self.code_editor = editor

    def sizeHint(self):
        return QtCore.QSize(self.code_editor.line_number_area_width(), 0)

    def paintEvent(self, event):
        self.code_editor.line_number_area_paint_event(event)

    #def paintEvent(self, event):
    #    icon_size = int(editor.fontMetrics().height() * 0.6)
    #    dot_radius = int(editor.fontMetrics().height() * 0.2)

    def mousePressEvent(self, event):
        # Delegate click to editor for folding logic
        self.code_editor.handle_gutter_click(event)
        super(LineNumberArea, self).mousePressEvent(event)


class AdvancedCodeEditor(PersistentTextEdit):
    """
    PersistentTextEdit subclass with:
      - VSCode-like line-number gutter
      - Simple indent-based fold markers and click-to-fold
    All existing TextEditor logic still works, because this is a
    drop-in subclass of PersistentTextEdit / QTextEdit.
    """
    def __init__(self, parent=None):
        super(AdvancedCodeEditor, self).__init__(parent)

        # Per-editor gutter configuration (may be overridden by TextEditorWidget)
        self.show_line_numbers = True
        self.show_fold_markers = True
        self.gutter_scale = 1.0
        self.fold_icon_style = "triangle"

        # Multi-cursor + drag state
        self.additional_cursors = []
        self._drag_start_pos = None

        # Bookmarks per editor: map line -> color index
        self.bookmarked_lines = {}
        self.bookmark_palette = [
            QtGui.QColor("#ff5555"),  # red
            QtGui.QColor("#50fa7b"),  # green
            QtGui.QColor("#8be9fd"),  # cyan
            QtGui.QColor("#bd93f9"),  # purple
            QtGui.QColor("#f1fa8c"),  # yellow
            QtGui.QColor("#ff79c6"),  # pink
        ]

        self.line_number_area = LineNumberArea(self)

        # Keep track of folding state via QTextBlock.userState:
        #   0 -> normal
        #   1 -> folded block header
        self.document().blockCountChanged.connect(self.update_line_number_area_width)
        self.verticalScrollBar().valueChanged.connect(self.update_line_number_area)
        self.cursorPositionChanged.connect(self.update_line_number_area)

        self.update_line_number_area_width(0)

    def toggle_bookmark_current_line(self):
        """Toggle bookmark on the current cursor line."""
        try:
            block = self.textCursor().block()
            bn = block.blockNumber()
            if bn in self.bookmarked_lines:
                # Remove existing bookmark
                self.bookmarked_lines.pop(bn, None)
            else:
                # Assign next color index in a cycling palette
                next_index = 0
                if self.bookmarked_lines:
                    # Use max existing index + 1
                    try:
                        next_index = max(self.bookmarked_lines.values()) + 1
                    except Exception:
                        next_index = 0
                palette_len = len(getattr(self, "bookmark_palette", [])) or 1
                self.bookmarked_lines[bn] = next_index % palette_len
            self.update_line_number_area()
        except Exception:
            pass

    def clear_bookmark_current_line(self):
        """Remove bookmark on the current cursor line, if any."""
        try:
            block = self.textCursor().block()
            bn = block.blockNumber()
            if bn in self.bookmarked_lines:
                self.bookmarked_lines.pop(bn, None)
                self.update_line_number_area()
        except Exception:
            pass

    def _iter_bookmarks_sorted(self):
        """Return sorted list of bookmarked line numbers."""
        return sorted(self.bookmarked_lines.keys())

    def goto_next_bookmark(self):
        """Jump to the next bookmark from the current line."""
        if not self.bookmarked_lines:
            return
        current_bn = self.textCursor().block().blockNumber()
        lines = self._iter_bookmarks_sorted()
        for ln in lines:
            if ln > current_bn:
                target = ln
                break
        else:
            target = lines[0]
        self._goto_bookmark_line(target)

    def goto_previous_bookmark(self):
        """Jump to the previous bookmark from the current line."""
        if not self.bookmarked_lines:
            return
        current_bn = self.textCursor().block().blockNumber()
        lines = self._iter_bookmarks_sorted()
        for ln in reversed(lines):
            if ln < current_bn:
                target = ln
                break
        else:
            target = lines[-1]
        self._goto_bookmark_line(target)

    def _goto_bookmark_line(self, line_number):
        """Move cursor to the given bookmarked line number."""
        doc = self.document()
        block = doc.findBlockByNumber(line_number)
        if not block.isValid():
            return
        cursor = QtGui.QTextCursor(block)
        cursor.movePosition(QtGui.QTextCursor.StartOfBlock)
        self.setTextCursor(cursor)
        self.centerCursor()

    # ----- Gutter geometry / repaint helpers ------------------- #
    def line_number_area_width(self):
        """Compute gutter width based on number of digits + fold marker space."""
        digits = len(str(max(1, self.document().blockCount())))
        fm = self.fontMetrics()
        # If line numbers are hidden, keep a small digit span to avoid collapsing
        if not getattr(self, "show_line_numbers", True):
            digits = 2
        base_space = 6 + fm.horizontalAdvance('9') * digits + 16
        space = int(base_space * float(getattr(self, "gutter_scale", 1.0)))
        return space

    def update_line_number_area_width(self, _=0):
        """Adjust viewport margins to make room for gutter."""
        self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)

    def update_line_number_area(self, *_args):
        """Trigger repaint of gutter + editor viewport."""
        if self.viewport() is not None:
            self.viewport().update()
        if self.line_number_area is not None:
            self.line_number_area.update()

    def resizeEvent(self, event):
        """Keep gutter aligned with the text viewport."""
        super(AdvancedCodeEditor, self).resizeEvent(event)
        cr = self.contentsRect()
        self.line_number_area.setGeometry(
            QtCore.QRect(cr.left(), cr.top(),
                         self.line_number_area_width(), cr.height())
        )

    # ----- Painting of numbers + fold markers ------------------ #
    def line_number_area_paint_event(self, event):
        """Draw line numbers and VSCode-style fold markers."""
        painter = QtGui.QPainter(self.line_number_area)
        painter.fillRect(event.rect(), QtGui.QColor("#252525"))

        doc = self.document()
        layout = doc.documentLayout()
        if layout is None:
            return

        # Scroll offset
        scroll_y = self.verticalScrollBar().value()

        block = doc.firstBlock()
        block_number = 0

        # Colors
        number_color = QtGui.QColor("#7f7f7f")
        active_number_color = QtGui.QColor("#ffffff")
        fold_marker_color = QtGui.QColor("#f8f8f2")

        current_block = self.textCursor().block()
        fm = self.fontMetrics()
        baseline = fm.ascent()

        while block.isValid():
            rect = layout.blockBoundingRect(block)
            top = rect.top() - scroll_y
            bottom = rect.bottom() - scroll_y

            if bottom < event.rect().top():
                block = block.next()
                block_number += 1
                continue

            if top > event.rect().bottom():
                break

            if block.isVisible():
                if getattr(self, "show_line_numbers", True):
                    number = str(block_number + 1)
                    # Right-align the number
                    x = self.line_number_area.width() - 4 - fm.horizontalAdvance(number)
                    y = int(top) + baseline

                    # Highlight current line number
                    if block == current_block:
                        painter.setPen(active_number_color)
                    else:
                        painter.setPen(number_color)
                    painter.drawText(x, y, number)

                # Fold marker region (left side in gutter)
                if getattr(self, "show_fold_markers", True) and self._block_can_fold(block):
                    marker_rect = QtCore.QRect(4, int(top) + 1, 12, 12)
                    self._draw_fold_marker(painter, marker_rect, block, fold_marker_color)

                # Bookmark indicator (small circle, colored per bookmark)
                try:
                    bn = block.blockNumber()
                    bm_map = getattr(self, "bookmarked_lines", {})
                    if isinstance(bm_map, dict) and bn in bm_map:
                        idx = bm_map.get(bn, 0)
                        palette = getattr(self, "bookmark_palette", [])
                        if palette:
                            color = palette[idx % len(palette)]
                        else:
                            color = QtGui.QColor("#ff5555")
                        cx = 6
                        cy = int(top) + rect.height() // 2
                        painter.setBrush(color)
                        painter.setPen(QtCore.Qt.NoPen)
                        painter.drawEllipse(QtCore.QPoint(int(cx), int(cy)), 3, 3)
                except Exception:
                    pass

            block = block.next()
            block_number += 1

    def _draw_fold_marker(self, painter, rect, block, color):
        """Draw a small triangle marker, right (collapsed) or down (expanded),
        and tint it differently when the block is folded.
        """
        painter.save()
        painter.setRenderHint(QtGui.QPainter.Antialiasing, True)
        painter.setPen(QtCore.Qt.NoPen)

        # Different colors for expanded vs collapsed
        if block.userState() == 1:
            # Collapsed -> warm accent
            painter.setBrush(QtGui.QColor("#ffb86c"))
        else:
            # Expanded -> default bright
            painter.setBrush(color)

        path = QtGui.QPainterPath()
        if block.userState() == 1:
            # Collapsed -> triangle pointing right
            path.moveTo(rect.left() + 2, rect.top() + rect.height() / 2.0)
            path.lineTo(rect.right() - 2, rect.top() + 2)
            path.lineTo(rect.right() - 2, rect.bottom() - 2)
        else:
            # Expanded -> triangle pointing down
            path.moveTo(rect.left() + 2, rect.top() + 2)
            path.lineTo(rect.right() - 2, rect.top() + 2)
            path.lineTo(rect.left() + rect.width() / 2.0, rect.bottom() - 2)

        path.closeSubpath()
        painter.drawPath(path)
        painter.restore()

    # ----- Folding logic (simple indent-based) ----------------- #
    def _line_indent(self, text):
        """Compute a simple indent level based on spaces/tabs."""
        count = 0
        for ch in text:
            if ch == " ":
                count += 1
            elif ch == "\t":
                count += 4
            else:
                break
        return count

    def _block_can_fold(self, block):
        """
        Decide if a block is a fold header:
        - Non-empty
        - Next visible block exists and has strictly greater indent
        """
        text = block.text()
        if not text.strip():
            return False

        this_indent = self._line_indent(text)
        # Find next non-empty block
        nxt = block.next()
        while nxt.isValid() and not nxt.text().strip():
            nxt = nxt.next()
        if not nxt.isValid():
            return False

        next_indent = self._line_indent(nxt.text())
        return next_indent > this_indent

    def handle_gutter_click(self, event):
        """Map a click in the gutter to a block.

        - Ctrl+LeftClick  -> toggle bookmark on that line
        - LeftClick       -> toggle folding if the block can fold
        """
        if event.button() != QtCore.Qt.LeftButton:
            return

        y = event.pos().y()
        doc = self.document()
        layout = doc.documentLayout()
        if layout is None:
            return

        scroll_y = self.verticalScrollBar().value()
        block = doc.firstBlock()

        while block.isValid():
            rect = layout.blockBoundingRect(block)
            top = rect.top() - scroll_y
            bottom = rect.bottom() - scroll_y

            if top <= y <= bottom:
                if event.modifiers() & QtCore.Qt.ControlModifier:
                    # Toggle bookmark on this block
                    try:
                        bn = block.blockNumber()
                        if bn in self.bookmarked_lines:
                            self.bookmarked_lines.pop(bn, None)
                        else:
                            next_index = 0
                            if self.bookmarked_lines:
                                try:
                                    next_index = max(self.bookmarked_lines.values()) + 1
                                except Exception:
                                    next_index = 0
                            palette_len = len(getattr(self, "bookmark_palette", [])) or 1
                            self.bookmarked_lines[bn] = next_index % palette_len
                        self.update_line_number_area()
                    except Exception:
                        pass
                else:
                    # Toggle folding on this block if possible
                    if self._block_can_fold(block) or block.userState() == 1:
                        self._toggle_fold_block(block)
                break
            block = block.next()

    def _toggle_fold_block(self, header_block):
        """Collapse/expand all following lines with greater indent.

        We hide/show blocks and also try to force the QTextDocument layout
        to recompute so we don't keep big vertical gaps in the view.
        """
        text = header_block.text()
        if not text.strip():
            return

        base_indent = self._line_indent(text)
        doc = self.document()
        layout = doc.documentLayout()

        is_currently_folded = (header_block.userState() == 1)

        # Always keep header visible with normal line count
        header_block.setVisible(True)
        header_block.setLineCount(1)

        block = header_block.next()

        if not is_currently_folded:
            # Fold now
            header_block.setUserState(1)
            while block.isValid():
                t = block.text()
                # Stop when we hit a non-empty line with indent <= base
                if t.strip():
                    ind = self._line_indent(t)
                    if ind <= base_indent:
                        break
                # Hide this block; for QTextEdit this does not fully
                # collapse height, but we still zero line count to help.
                block.setVisible(False)
                try:
                    block.setLineCount(0)
                except Exception:
                    pass
                block = block.next()
        else:
            # Unfold now
            header_block.setUserState(0)
            while block.isValid():
                t = block.text()
                if t.strip():
                    ind = self._line_indent(t)
                    if ind <= base_indent:
                        break
                block.setVisible(True)
                try:
                    block.setLineCount(1)
                except Exception:
                    pass
                # Reset any nested folded headers to normal when unfolding this region
                if block.userState() == 1:
                    block.setUserState(0)
                block = block.next()

        # Force layout + repaint as strongly as possible
        if layout is not None:
            try:
                layout.invalidate()
            except Exception:
                pass
            try:
                layout.update()
            except Exception:
                pass

        self.updateGeometry()
        self.update_line_number_area()
        self.viewport().update()


    def _auto_indent_new_line(self):
        """Simple auto-indent: copy indent from previous line and handle ':' one-level extra."""
        cursor = self.textCursor()
        block = cursor.block().previous()
        if not block.isValid():
            return
        text = block.text()
        leading_ws = ""
        for ch in text:
            if ch in (" ", "\t"):
                leading_ws += ch
            else:
                break
        extra = ""
        if text.rstrip().endswith(":"):
            extra = " " * INDENT_TAB_SIZE
        indent = leading_ws + extra
        if indent:
            cursor.insertText(indent)

    def _change_indent_for_lines(self, increase=True):
        """Indent or unindent current line / selected lines by INDENT_TAB_SIZE."""
        cursor = self.textCursor()
        doc = self.document()

        if cursor.hasSelection():
            start = cursor.selectionStart()
            end = cursor.selectionEnd()
            cursor.setPosition(start)
            start_block = cursor.block()
            cursor.setPosition(end)
            end_block = cursor.block()
        else:
            start_block = cursor.block()
            end_block = start_block

        block = start_block
        while True:
            text = block.text()
            if increase:
                cursor = QtGui.QTextCursor(block)
                cursor.movePosition(QtGui.QTextCursor.StartOfBlock)
                cursor.insertText(" " * INDENT_TAB_SIZE)
            else:
                # Unindent: remove up to INDENT_TAB_SIZE spaces/tabs at start
                remove_count = 0
                for ch in text[:INDENT_TAB_SIZE]:
                    if ch == " ":
                        remove_count += 1
                    elif ch == "\t":
                        remove_count += 4
                    else:
                        break
                if remove_count > 0:
                    cursor = QtGui.QTextCursor(block)
                    cursor.movePosition(QtGui.QTextCursor.StartOfBlock)
                    for _ in range(remove_count):
                        cursor.deleteChar()
            if block == end_block:
                break
            block = block.next()

    def keyPressEvent(self, event):
        """Extend key handling with smart Tab, auto-indent, multi-cursor ESC clear,
        and auto-closing of brackets/quotes.
        """
        key = event.key()
        modifiers = event.modifiers()

        # ESC clears all additional cursors
        if key == QtCore.Qt.Key_Escape and self.additional_cursors:
            self.additional_cursors = []
            self._update_multi_cursor_selections()
            return

        # Auto-close brackets and quotes
        pairs = {
            QtCore.Qt.Key_ParenLeft: ("(", ")"),
            QtCore.Qt.Key_BracketLeft: ("[", "]"),
            QtCore.Qt.Key_BraceLeft: ("{", "}"),
            QtCore.Qt.Key_QuoteDbl: ('"', '"'),
            QtCore.Qt.Key_Apostrophe: ("'", "'"),
        }
        if key in pairs and not (modifiers & (QtCore.Qt.ControlModifier | QtCore.Qt.AltModifier)):
            open_ch, close_ch = pairs[key]
            cursor = self.textCursor()
            if cursor.hasSelection():
                text = cursor.selectedText()
                cursor.insertText(open_ch + text + close_ch)
            else:
                cursor.insertText(open_ch + close_ch)
                cursor.movePosition(QtGui.QTextCursor.Left)
            self.setTextCursor(cursor)
            return

        # Tab / Shift+Tab for indentation
        if key == QtCore.Qt.Key_Tab and not (modifiers & QtCore.Qt.ShiftModifier):
            self._change_indent_for_lines(increase=True)
            return
        if (key == QtCore.Qt.Key_Backtab) or (key == QtCore.Qt.Key_Tab and (modifiers & QtCore.Qt.ShiftModifier)):
            self._change_indent_for_lines(increase=False)
            return

        super(AdvancedCodeEditor, self).keyPressEvent(event)

        # Auto-indent after newline
        if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
            self._auto_indent_new_line()

    def mousePressEvent(self, event):
        """Support Ctrl+Click to add extra cursors; normal clicks behave normally."""
        if event.button() == QtCore.Qt.LeftButton:
            self._drag_start_pos = event.pos()
            if event.modifiers() & QtCore.Qt.ControlModifier:
                c = self.cursorForPosition(event.pos())
                if not c.isNull():
                    self.additional_cursors.append(c)
                    self._update_multi_cursor_selections()
                    return
        super(AdvancedCodeEditor, self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Start a text drag when the user drags with the left mouse button."""
        if event.buttons() & QtCore.Qt.LeftButton and self._drag_start_pos is not None:
            if (event.pos() - self._drag_start_pos).manhattanLength() >= QtWidgets.QApplication.startDragDistance():
                sel_text = self.textCursor().selectedText()
                if sel_text:
                    drag = QtGui.QDrag(self)
                    mime = QtCore.QMimeData()
                    mime.setText(sel_text)
                    drag.setMimeData(mime)
                    drag.exec_(QtCore.Qt.CopyAction)
                    return
        super(AdvancedCodeEditor, self).mouseMoveEvent(event)

    def _update_multi_cursor_selections(self):
        """Draw visual carets for additional cursors using extra selections."""
        MULTI_KEY = 2001
        selections = []
        for sel in self.extraSelections():
            fmt = sel.format
            try:
                has_prop = fmt.property(MULTI_KEY)
            except Exception:
                has_prop = None
            if not has_prop:
                selections.append(sel)

        for c in self.additional_cursors:
            cursor = QtGui.QTextCursor(c)
            if cursor.atEnd():
                # Nothing to highlight, skip
                continue
            cursor.movePosition(QtGui.QTextCursor.NextCharacter, QtGui.QTextCursor.KeepAnchor)
            sel = QtWidgets.QTextEdit.ExtraSelection()
            sel.cursor = cursor
            fmt = QtGui.QTextCharFormat()
            fmt.setBackground(QtGui.QColor("#44475a"))
            fmt.setProperty(MULTI_KEY, True)
            sel.format = fmt
            selections.append(sel)

        self.setExtraSelections(selections)

    def paintEvent(self, event):
        """Draw normal text, then indentation guides."""
        super(AdvancedCodeEditor, self).paintEvent(event)

        painter = QtGui.QPainter(self.viewport())
        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)
        color = QtGui.QColor("#333333")
        pen = QtGui.QPen(color)
        pen.setStyle(QtCore.Qt.DotLine)
        painter.setPen(pen)

        doc = self.document()
        layout = doc.documentLayout()
        if layout is None:
            return

        scroll_y = self.verticalScrollBar().value()
        block = doc.firstBlock()

        fm = self.fontMetrics()
        char_width = fm.horizontalAdvance(" ")

        while block.isValid():
            rect = layout.blockBoundingRect(block)
            top = rect.top() - scroll_y
            bottom = rect.bottom() - scroll_y
            if bottom < 0:
                block = block.next()
                continue
            if top > self.viewport().height():
                break

            text = block.text()
            indent_px = self._line_indent(text)
            if indent_px > 0:
                levels = int(indent_px / INDENT_TAB_SIZE)
                for level in range(levels):
                    x = 4 + (level + 0.5) * (INDENT_TAB_SIZE * char_width)
                    painter.drawLine(int(x), int(top), int(x), int(bottom))
            block = block.next()

        painter.end()


# ------------------------------------------------------------- #
#  Clickable label (About link)                                 #
# ------------------------------------------------------------- #
class ClickableLabel(QtWidgets.QLabel):
    """Label that behaves like a hyperlink and emits 'clicked'."""
    clicked = QtCore.Signal()

    def __init__(self, text=""):
        """Autogenerated stub documentation removed for clarity."""
        super().__init__(text)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setStyleSheet("color: #dddddd; text-decoration: underline;")

    def enterEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        self.setStyleSheet("color: #ffffff; text-decoration: underline;")

    def leaveEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        self.setStyleSheet("color: #dddddd; text-decoration: underline;")

    def mousePressEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        self.clicked.emit()


# ------------------------------------------------------------- #
#  HoverButton (styled push button)                             #
# ------------------------------------------------------------- #
class HoverButton(QtWidgets.QPushButton):
    """Push button with a consistent dark style and hover effect."""
    def __init__(self, text="", parent=None):
        """Autogenerated stub documentation removed for clarity."""
        super().__init__(text, parent)
        self.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        self.setStyleSheet(
            """
            
            QPushButton {
                background-color: #3a3a3a;
                border: 1px solid #5a5a5a;
                padding: 4px 8px;
                border-radius: 2px;
                color: #dddddd;
                min-width: 0px;
            }
            QPushButton:hover { background-color: #444444; }
            QPushButton:checked {
                background-color: #505050;
                border: 1px solid #888888;
            }

            """
        )


# ------------------------------------------------------------- #
#  Find / Replace Dialog                                        #
# ------------------------------------------------------------- #
class FindReplaceDialog(QtWidgets.QDialog):
    """Simple modal dialog for finding and replacing text."""

    def __init__(self, parent, text_edit):
        """Autogenerated stub documentation removed for clarity."""
        super().__init__(parent)
        self.text_edit = text_edit
        self.setWindowTitle("Find / Replace")
        self.setModal(True)
        self.setFixedSize(300, 140)
        self.setStyleSheet(
            """
            QDialog { background-color: #2c2c2c; color: #dddddd; }
            QLineEdit {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                color: #dddddd;
                padding: 4px;
            }
            QPushButton {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                padding: 4px 8px;
                border-radius: 3px;
                color: #dddddd;
            }
            QPushButton:hover { background-color: #4a4a4a; }
            """
        )

        layout = QtWidgets.QGridLayout(self)

        layout.addWidget(QtWidgets.QLabel("Find:"), 0, 0)
        self.find_input = QtWidgets.QLineEdit()
        layout.addWidget(self.find_input, 0, 1)

        layout.addWidget(QtWidgets.QLabel("Replace:"), 1, 0)
        self.replace_input = QtWidgets.QLineEdit()
        layout.addWidget(self.replace_input, 1, 1)

        self.find_button = QtWidgets.QPushButton("Find Next")
        self.replace_button = QtWidgets.QPushButton("Replace")
        self.replace_all_button = QtWidgets.QPushButton("Replace All")

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.find_button)
        btn_layout.addWidget(self.replace_button)
        btn_layout.addWidget(self.replace_all_button)
        layout.addLayout(btn_layout, 2, 0, 1, 2)

        self.find_button.clicked.connect(self.find_text)
        self.replace_button.clicked.connect(self.replace_text)
        self.replace_all_button.clicked.connect(self.replace_all)

        self.last_search = ""

    def find_text(self):
        """Autogenerated stub documentation removed for clarity."""
        text = self.find_input.text()
        if not text:
            return
        doc = self.text_edit.document()
        cursor = self.text_edit.textCursor()
        if text != self.last_search:
            cursor.movePosition(QtGui.QTextCursor.Start)
        found = doc.find(text, cursor)
        if found.isNull():
            QtWidgets.QMessageBox.information(self, "Find", "No more matches found.")
        else:
            self.text_edit.setTextCursor(found)
        self.last_search = text

    def replace_text(self):
        """Autogenerated stub documentation removed for clarity."""
        cursor = self.text_edit.textCursor()
        if cursor.hasSelection():
            cursor.insertText(self.replace_input.text())
            self.find_text()

    def replace_all(self):
        """Autogenerated stub documentation removed for clarity."""
        text = self.find_input.text()
        if not text:
            return
        replace = self.replace_input.text()
        content = self.text_edit.toPlainText().replace(text, replace)
        self.text_edit.setPlainText(content)
        QtWidgets.QMessageBox.information(self, "Replace All", "All occurrences replaced.")



# ------------------------------------------------------------- #
#  Autosave UI (History + Settings)                             #
# ------------------------------------------------------------- #
class AutosaveHistoryDialog(QtWidgets.QDialog):
    """Autosave history browser for the current tab (with preview)."""

    def __init__(self, parent, editor_widget):
        super().__init__(parent)
        self.editor_widget = editor_widget
        self.setWindowTitle("Autosave History")
        self.setModal(True)

        # Resizable window (small UX improvement)
        self.setMinimumSize(560, 320)
        self.resize(720, 380)

        self.setStyleSheet(
            """
            QDialog { background-color: #2c2c2c; color: #dddddd; }
            QListWidget {
                background-color: #1e1e1e;
                border: 1px solid #444444;
                border-radius: 3px;
                color: #dddddd;
            }
            QTextEdit {
                background-color: #1e1e1e;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 6px;
                color: #dddddd;
            }
            QPushButton {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                padding: 4px 10px;
                border-radius: 3px;
                color: #dddddd;
            }
            QPushButton:hover { background-color: #4a4a4a; }
            QLabel { color: #cccccc; }
            """
        )

        layout = QtWidgets.QVBoxLayout(self)

        self.info_label = QtWidgets.QLabel("")
        layout.addWidget(self.info_label)

        self.hint_label = QtWidgets.QLabel(
            "Autosave snapshots are kept automatically. You can delete individual snapshots when theyre no longer needed."
        )
        self.hint_label.setStyleSheet("color: #888888; font-size: 10px;")
        self.hint_label.setWordWrap(True)
        layout.addWidget(self.hint_label)

        # Splitter: snapshots list + preview
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)

        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.list_widget.itemSelectionChanged.connect(self.on_selection_changed)
        self.list_widget.itemDoubleClicked.connect(lambda _it: self.on_open_new())
        self.splitter.addWidget(self.list_widget)

        self.preview = QtWidgets.QTextEdit()
        self.preview.setReadOnly(True)
        try:
            self.preview.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        except Exception:
            pass
        self.preview.setPlaceholderText("Select a snapshot to preview it")
        self.splitter.addWidget(self.preview)

        # Give more space to the list by default
        try:
            self.splitter.setStretchFactor(0, 2)
            self.splitter.setStretchFactor(1, 1)
        except Exception:
            pass

        layout.addWidget(self.splitter, 1)

        btn_row = QtWidgets.QHBoxLayout()
        self.restore_btn = QtWidgets.QPushButton("Restore in Tab")
        self.open_new_btn = QtWidgets.QPushButton("Open as New Tab")
        self.delete_btn = QtWidgets.QPushButton("Delete Snapshot")
        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.close_btn = QtWidgets.QPushButton("Close")

        btn_row.addWidget(self.restore_btn)
        btn_row.addWidget(self.open_new_btn)
        btn_row.addWidget(self.delete_btn)
        btn_row.addStretch()
        btn_row.addWidget(self.refresh_btn)
        btn_row.addWidget(self.close_btn)
        layout.addLayout(btn_row)

        self.restore_btn.clicked.connect(self.on_restore)
        self.open_new_btn.clicked.connect(self.on_open_new)
        self.delete_btn.clicked.connect(self.on_delete)
        self.refresh_btn.clicked.connect(self.refresh)
        self.close_btn.clicked.connect(self.close)

        self._set_buttons_enabled(False)
        self.refresh()

    def _set_buttons_enabled(self, enabled):
        try:
            self.restore_btn.setEnabled(enabled)
            self.open_new_btn.setEnabled(enabled)
            self.delete_btn.setEnabled(enabled)
        except Exception:
            pass

    def _selected_snapshot(self):
        item = self.list_widget.currentItem()
        if not item:
            return None
        return item.data(QtCore.Qt.UserRole)

    def refresh(self):
        self.list_widget.clear()
        self.preview.clear()
        self._set_buttons_enabled(False)

        editor = self.editor_widget.current_editor()
        if not editor:
            self.info_label.setText("No active tab.")
            return

        snaps = self.editor_widget.list_autosave_snapshots(editor)
        title = self.editor_widget.tab_widget.tabText(self.editor_widget.tab_widget.indexOf(editor))
        title = title.replace(" ", "")
        self.info_label.setText(f"Tab: {title}  |  Snapshots: {len(snaps)}  (doubleclick opens as new tab)")

        for snap in snaps:
            label = f"{snap.get('timestamp_human','')}    {snap.get('size_kb','')} KB"
            it = QtWidgets.QListWidgetItem(label)
            it.setData(QtCore.Qt.UserRole, snap)
            self.list_widget.addItem(it)

        if self.list_widget.count() > 0:
            self.list_widget.setCurrentRow(0)
            self.on_selection_changed()
        else:
            self.preview.setPlainText("No snapshots found for this tab yet.")

    def _load_snapshot_text(self, snap, max_chars=20000):
        """Load snapshot text safely. Preview is capped to avoid lag on big files."""
        try:
            p = snap.get("path")
            if not p:
                return None
            with io.open(p, "r", encoding="utf-8") as f:
                data = f.read()
            if data is None:
                return None
            if len(data) > max_chars:
                return data[:max_chars] + "\n\n(preview truncated)"
            return data
        except Exception:
            return None

    def on_selection_changed(self):
        snap = self._selected_snapshot()
        if not snap:
            self.preview.clear()
            self._set_buttons_enabled(False)
            return

        self._set_buttons_enabled(True)

        content = self._load_snapshot_text(snap)
        if content is None:
            self.preview.setPlainText("(Could not read this snapshot.)")
            return

        # Tiny UX: show where the caret would start
        self.preview.setPlainText(content)
        try:
            c = self.preview.textCursor()
            c.movePosition(QtGui.QTextCursor.Start)
            self.preview.setTextCursor(c)
        except Exception:
            pass

    def on_restore(self):
        snap = self._selected_snapshot()
        if not snap:
            return
        content = self._load_snapshot_text(snap, max_chars=10**9)  # full content
        if content is None:
            return
        self.editor_widget.restore_snapshot_into_current_tab(content)

    def on_open_new(self):
        snap = self._selected_snapshot()
        if not snap:
            return
        content = self._load_snapshot_text(snap, max_chars=10**9)  # full content
        if content is None:
            return
        self.editor_widget.open_snapshot_as_new_tab(content)

    def on_delete(self):
        snap = self._selected_snapshot()
        if not snap:
            return
        p = snap.get("path")
        if not p:
            return
        human = snap.get("timestamp_human", "this snapshot")
        confirm = QtWidgets.QMessageBox.question(
            self,
            "Delete Snapshot",
            f"Delete autosave snapshot from:\n{human}?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No,
        )
        if confirm != QtWidgets.QMessageBox.Yes:
            return
        try:
            os.remove(p)
            meta = snap.get("meta_path")
            if meta and os.path.exists(meta):
                try:
                    os.remove(meta)
                except Exception:
                    pass
        except Exception:
            pass
        self.refresh()

class AutosaveSettingsDialog(QtWidgets.QDialog):
    """Basic autosave settings dialog."""

    def __init__(self, parent, editor_widget):
        super().__init__(parent)
        self.editor_widget = editor_widget
        self.setWindowTitle("Autosave Settings")
        self.setModal(True)
        self.setFixedSize(320, 160)
        self.setStyleSheet(
            """
            QDialog { background-color: #2c2c2c; color: #dddddd; }
            QSpinBox {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                padding: 2px 5px;
                border-radius: 3px;
                color: #dddddd;
            }
            QPushButton {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                padding: 4px 10px;
                border-radius: 3px;
                color: #dddddd;
            }
            QPushButton:hover { background-color: #4a4a4a; }
            QLabel { color: #cccccc; }
            """
        )

        layout = QtWidgets.QGridLayout(self)

        self.idle_spin = QtWidgets.QSpinBox()
        self.idle_spin.setRange(1, 60)
        self.idle_spin.setValue(max(1, int(getattr(self.editor_widget, "autosave_idle_ms", 5000) / 1000)))

        self.interval_spin = QtWidgets.QSpinBox()
        self.interval_spin.setRange(1, 60)
        self.interval_spin.setValue(max(1, int(getattr(self.editor_widget, "autosave_interval_ms", 120000) / 60000)))

        self.versions_spin = QtWidgets.QSpinBox()
        self.versions_spin.setRange(1, 200)
        self.versions_spin.setValue(int(getattr(self.editor_widget, "autosave_max_versions", 20)))

        layout.addWidget(QtWidgets.QLabel("Idle (seconds):"), 0, 0)
        layout.addWidget(self.idle_spin, 0, 1)
        layout.addWidget(QtWidgets.QLabel("Interval (minutes):"), 1, 0)
        layout.addWidget(self.interval_spin, 1, 1)
        layout.addWidget(QtWidgets.QLabel("Max versions:"), 2, 0)
        layout.addWidget(self.versions_spin, 2, 1)

        btn_row = QtWidgets.QHBoxLayout()
        self.save_btn = QtWidgets.QPushButton("Apply")
        self.close_btn = QtWidgets.QPushButton("Close")
        btn_row.addStretch()
        btn_row.addWidget(self.save_btn)
        btn_row.addWidget(self.close_btn)
        layout.addLayout(btn_row, 3, 0, 1, 2)

        self.save_btn.clicked.connect(self.apply)
        self.close_btn.clicked.connect(self.close)

    def apply(self):
        self.editor_widget.autosave_idle_ms = int(self.idle_spin.value() * 1000)
        self.editor_widget.autosave_interval_ms = int(self.interval_spin.value() * 60000)
        self.editor_widget.autosave_max_versions = int(self.versions_spin.value())
        try:
            self.editor_widget.last_edit_time = QtCore.QDateTime.currentDateTime()
            self.editor_widget.last_autosave_time = QtCore.QDateTime.currentDateTime()
        except Exception:
            pass
        self.close()

# ------------------------------------------------------------- #
#  Main Text Editor Widget                                      #
# ------------------------------------------------------------- #
class ColorTabBar(QtWidgets.QTabBar):
    """Custom tab bar that lets us draw a thin colored underline per tab."""

    def paintEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        super(ColorTabBar, self).paintEvent(event)
        painter = QtGui.QPainter(self)
        for index in range(self.count()):
            rect = self.tabRect(index)
            color = self.tabTextColor(index)
            if not color.isValid():
                continue
            underline_rect = QtCore.QRect(rect.left() + 4, rect.bottom() - 2, rect.width() - 8, 2)
            painter.fillRect(underline_rect, color)
        painter.end()


class TextEditorWidget(QtWidgets.QWidget):
    """Main Nuke Text Editor widget with tabs."""

    DEFAULT_FONT_FAMILY = "Consolas"
    DEFAULT_FONT_SIZE = 9
    MAX_RECENT_FILES = 5

    def __init__(self, parent=None):
        """Autogenerated stub documentation removed for clarity."""
        super().__init__(parent)
        self.setWindowTitle("Text Editor")
        self.setMinimumSize(800, 500)

        # Global state per window (per tab stored on each editor)
        self.is_modified = False
        self.current_file_path = None
        self.recent_files = []

        # Gutter settings (global)
        self.gutter_show_line_numbers = True
        self.gutter_show_fold_markers = True
        self.gutter_scale = 1.0
        self.gutter_icon_style = "triangle"

        # Reference to the special "+" tab dummy widget
        self.plus_tab_dummy = None

        # Autosave configuration (Redesign: snapshots + toggle)
        # - Autosave can be turned ON/OFF from View menu
        # - Autosave writes separate snapshot files (never overwrites the real file)
        self.autosave_enabled = True
        self.autosave_interval_ms = 120000  # 2 minutes safety net
        self.autosave_idle_ms = 5000        # 5 seconds idle
        self.autosave_max_versions = 20     # per tab/file
        self.autosave_root = os.path.join(QtCore.QDir.homePath(), ".nuke", "TextEditor", "autosave")
        try:
            os.makedirs(self.autosave_root, exist_ok=True)
        except Exception:
            pass

        self.last_edit_time = QtCore.QDateTime.currentDateTime()
        self.last_autosave_time = QtCore.QDateTime.currentDateTime()
        self.autosave_timer = QtCore.QTimer(self)
        self.autosave_timer.setInterval(2000)  # check every 2 seconds
        self.autosave_timer.timeout.connect(self.handle_autosave)
        self.autosave_timer.start()


        # Bookmark navigation shortcuts
        self.shortcut_toggle_bookmark = QtGui.QShortcut(QtGui.QKeySequence("Ctrl+F2"), self)
        self.shortcut_next_bookmark = QtGui.QShortcut(QtGui.QKeySequence("F2"), self)
        self.shortcut_prev_bookmark = QtGui.QShortcut(QtGui.QKeySequence("Shift+F2"), self)
        self.shortcut_toggle_bookmark.activated.connect(self.toggle_bookmark_current_line)
        self.shortcut_next_bookmark.activated.connect(self.goto_next_bookmark)
        self.shortcut_prev_bookmark.activated.connect(self.goto_previous_bookmark)

        # Global widget style
        self.setStyleSheet(
            """
            QWidget {
                background-color: #2c2c2c;
                color: #dddddd;
                font-size: 11px;
            }
            QTextEdit {
                background-color: #1e1e1e;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 6px;
                color: #e6e6e6;
            }
            QComboBox, QFontComboBox {
                background-color: #3c3c3c;
                border: 1px solid #555555;
                padding: 2px 5px;
                border-radius: 3px;
                color: #dddddd;
            }
            QLabel { color: #e0e0e0; }
            QMenu {
                background-color: #3c3c3c;
                color: #dddddd;
            }
            QMenu::item:selected { background-color: #555555; }
            """
        )

        # --------------------------------------------------------- #
        #  Central tab widget + file browser                        #
        # --------------------------------------------------------- #
        self.tab_widget = QtWidgets.QTabWidget(self)
        self.tab_widget.setTabBar(ColorTabBar())
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.tab_widget.tabCloseRequested.connect(self.close_tab)
        self.tab_widget.currentChanged.connect(self.on_tab_changed)

        # Tab bar styling + context menu + middle-click handling
        self.tab_widget.setStyleSheet(
            """
            QTabBar::tab {
                margin-top: 4px;
                padding-left: 6px;
                background: #2b2b2b;
                color: #dddddd;
                padding: 4px 8px;
                border-top-left-radius: 3px;
                border-top-right-radius: 3px;
            }
            QTabBar::tab:selected {
                background: #3c3c3c;
            }
            QTabBar::tab:!selected {
                margin-top: 2px;
            }
            """
        )
        tab_bar = self.tab_widget.tabBar()
        tab_bar.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        tab_bar.customContextMenuRequested.connect(self.show_tab_context_menu)
        tab_bar.tabBarClicked.connect(self.on_tab_bar_clicked)
        tab_bar.installEventFilter(self)

        # Word/character status bar label (bottom-left)
        self.status_bar = QtWidgets.QLabel("Words: 0 | Characters: 0")
        self.status_bar.setAlignment(QtCore.Qt.AlignLeft)
        self.status_bar.setStyleSheet("color: #888888; padding: 4px; font-size: 10px;")

        # Autosave status (bottom bar)
        self.autosave_status = QtWidgets.QLabel("")
        self.autosave_status.setAlignment(QtCore.Qt.AlignLeft)
        self.autosave_status.setStyleSheet("color: #666666; padding: 4px; font-size: 10px;")
        self.update_autosave_status_label()

        # File browser sidebar
        self.file_browser = FileBrowser(self)
        self.file_browser.file_selected.connect(self.load_file_from_browser)
        # Ensure file browser starts visible and comfortable width
        self.file_browser.setVisible(True)
        try:
            self.file_browser.setMinimumWidth(260)
        except Exception:
            pass

        # Sidebar toggle is now only controlled via menu (no Files button)
        self.sidebar_button = None

        # --------------------------------------------------------- #
                        # --------------------------------------------------------- #
        #  Formatting buttons                                       #
        # --------------------------------------------------------- #
        self.bold_button = HoverButton("B")
        self.bold_button.setCheckable(True)
        self.italic_button = HoverButton("I")
        self.italic_button.setCheckable(True)
        self.underline_button = HoverButton("U")
        self.underline_button.setCheckable(True)
        self.bullet_button = HoverButton("")
        self.color_button = HoverButton("Color")
        self.highlight_button = HoverButton("Highlight")
        self.undo_button = HoverButton("Undo")
        self.redo_button = HoverButton("Redo")

        # Bookmark toolbar buttons
        self.bookmark_prev_button = HoverButton("")
        self.bookmark_next_button = HoverButton("")
        self.bookmark_new_button = HoverButton("+")
        self.bookmark_delete_button = HoverButton("-")
        self.bookmark_list_button = HoverButton("")

        # Alignment dropdown
        self.align_dropdown = QtWidgets.QComboBox()
        self.align_dropdown.addItems(["Left", "Center", "Right", "Justify"])
        self.align_dropdown.setCurrentIndex(0)
        self.align_dropdown.setMinimumWidth(80)
        self.align_dropdown.setMaximumWidth(90)
        self.align_dropdown.currentIndexChanged.connect(self.change_alignment)

        # Font size combobox
        self.fontsize_combo = QtWidgets.QComboBox()
        self.fontsize_combo.addItems([str(i) for i in range(8, 25)])
        self.fontsize_combo.setCurrentText(str(self.DEFAULT_FONT_SIZE))

        # Font family combobox
        self.fontfamily_combo = QtWidgets.QFontComboBox()
        self.fontfamily_combo.setCurrentFont(QtGui.QFont(self.DEFAULT_FONT_FAMILY))
        self.fontfamily_combo.setMaximumHeight(24)
        self.fontfamily_combo.setMaximumWidth(130)
        self.fontfamily_combo.setMaxVisibleItems(8)
        self.fontfamily_combo.currentFontChanged.connect(self.preview_font)
        self.fontfamily_combo.activated.connect(self.change_fontfamily)

        # --------------------------------------------------------- #
        #  Nuke-style menu bar (File / Edit / View / Help)          #
        # --------------------------------------------------------- #
        self.menu_bar = QtWidgets.QMenuBar(self)
        self.menu_bar.setStyleSheet(
            """
            QMenuBar {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                          stop:0 #1f1f1f, stop:0.95 #1f1f1f,
                                          stop:1 #181818);
                color: #dddddd;
                padding-top: 5px;
                padding-bottom: 5px;
                border-bottom: 1px solid #444444;
            }
            QMenuBar::item {
                background: transparent;
                padding: 4px 8px;
                spacing: 2px;
            }
            QMenuBar::item:selected {
                background: #555555;
            }
            """
        )

        # File menu
        file_menu = self.menu_bar.addMenu("File")
        file_menu.addAction("New", self.new_file)
        file_menu.addAction("New Tab", self.new_tab)
        file_menu.addAction("Open", self.open)
        file_menu.addAction("Save", self.save)
        file_menu.addAction("Save As", self.save_as)
        file_menu.addSeparator()
        self.recent_menu_bar = file_menu.addMenu("Recent Files")
        file_menu.addSeparator()
        file_menu.addAction("Toggle File Browser", self.toggle_sidebar)
        file_menu.addSeparator()
        file_menu.addAction("Close Editor", self.close)

        # Edit menu
        edit_menu = self.menu_bar.addMenu("Edit")
        edit_menu.addAction("Undo", self.edit_undo)
        edit_menu.addAction("Redo", self.edit_redo)
        edit_menu.addSeparator()
        edit_menu.addAction("Find / Replace", self.show_find_replace)

        # View menu
        view_menu = self.menu_bar.addMenu("View")
        view_menu.addAction("Toggle File Browser", self.toggle_sidebar)
        view_menu.addSeparator()
        view_menu.addAction("Word Wrap", self.toggle_word_wrap)
        view_menu.addSeparator()

        # Autosave (snapshots) controls
        self.autosave_toggle_action = view_menu.addAction("Autosave")
        self.autosave_toggle_action.setCheckable(True)
        self.autosave_toggle_action.setChecked(bool(getattr(self, "autosave_enabled", True)))
        self.autosave_toggle_action.toggled.connect(self.set_autosave_enabled)

        autosave_history_action = view_menu.addAction("Autosave History...")
        autosave_history_action.triggered.connect(self.show_autosave_history)

        autosave_settings_action = view_menu.addAction("Autosave Settings...")
        autosave_settings_action.triggered.connect(self.show_autosave_settings)

        gutter_settings_action = view_menu.addAction("Gutter Settings...")
        gutter_settings_action.triggered.connect(self.show_gutter_settings)

        # Help menu
        help_menu = self.menu_bar.addMenu("Help")
        help_menu.addAction("About", self.show_about)

        # --------------------------------------------------------- #
        #  Toolbar layout (formatting only, full-width)             #
        # --------------------------------------------------------- #
        toolbar_layout = QtWidgets.QHBoxLayout()
        toolbar_layout.setContentsMargins(3, 3, 3, 3)
        toolbar_layout.setSpacing(6)
        # Formatting buttons first
        toolbar_layout.addWidget(self.bold_button)
        toolbar_layout.addWidget(self.italic_button)
        toolbar_layout.addWidget(self.underline_button)
        toolbar_layout.addWidget(self.bullet_button)
        toolbar_layout.addWidget(self.color_button)
        toolbar_layout.addWidget(self.highlight_button)
        toolbar_layout.addWidget(self.align_dropdown)
        # Then font size and font family combos (no labels)
        toolbar_layout.addWidget(self.fontsize_combo)
        toolbar_layout.addWidget(self.fontfamily_combo)
        # Undo/redo near formatting (left group)
        toolbar_layout.addWidget(self.undo_button)
        toolbar_layout.addWidget(self.redo_button)
        # Bookmark controls pinned to the right
        toolbar_layout.addStretch()
        toolbar_layout.addWidget(self.bookmark_prev_button)
        toolbar_layout.addWidget(self.bookmark_next_button)
        toolbar_layout.addWidget(self.bookmark_new_button)
        toolbar_layout.addWidget(self.bookmark_delete_button)
        toolbar_layout.addWidget(self.bookmark_list_button)


        # Split area: file browser + right panel (toolbar + tabs + editor)
        right_panel = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(0)
        right_layout.addLayout(toolbar_layout)
        right_layout.addWidget(self.tab_widget, 1)

        # Bottom docked Find / Replace panel (hidden by default)
        self.find_panel = QtWidgets.QWidget(right_panel)
        self.find_panel.setVisible(False)
        self.find_panel.setStyleSheet("background-color: #262626;")

        find_layout = QtWidgets.QHBoxLayout(self.find_panel)
        find_layout.setContentsMargins(6, 4, 6, 4)
        find_layout.setSpacing(4)

        self.find_input = QtWidgets.QLineEdit()
        self.replace_input = QtWidgets.QLineEdit()
        self.find_case_checkbox = QtWidgets.QCheckBox("Case")
        self.find_regex_checkbox = QtWidgets.QCheckBox("Regex")
        self.find_word_checkbox = QtWidgets.QCheckBox("Word")

        self.find_prev_button = HoverButton("Prev")
        self.find_next_button = HoverButton("Next")
        self.find_replace_button = HoverButton("Replace")
        self.find_replace_all_button = HoverButton("Replace All")
        self.find_close_button = HoverButton("X")

        find_layout.addWidget(QtWidgets.QLabel("Find:"))
        find_layout.addWidget(self.find_input, 1)
        find_layout.addWidget(QtWidgets.QLabel("Replace:"))
        find_layout.addWidget(self.replace_input, 1)
        find_layout.addWidget(self.find_case_checkbox)
        find_layout.addWidget(self.find_regex_checkbox)
        find_layout.addWidget(self.find_word_checkbox)
        find_layout.addWidget(self.find_prev_button)
        find_layout.addWidget(self.find_next_button)
        find_layout.addWidget(self.find_replace_button)
        find_layout.addWidget(self.find_replace_all_button)
        find_layout.addWidget(self.find_close_button)

        right_layout.addWidget(self.find_panel, 0)

        split_layout = QtWidgets.QHBoxLayout()
        split_layout.setContentsMargins(0, 0, 0, 0)
        split_layout.setSpacing(0)
        split_layout.addWidget(self.file_browser)
        split_layout.addWidget(right_panel, 1)

        
        # Bottom bar: word count + Zoom slider

        def apply_zoom_value(val):
            editor = self.current_editor()
            if not editor:
                return

            base = self.DEFAULT_FONT_SIZE
            scale = val / 100.0
            new_size = max(5, int(base * scale))

            # Build base font
            base_font = QtGui.QFont(self.DEFAULT_FONT_FAMILY, new_size)

            # Apply to editor widget + document
            editor.setFont(base_font)
            try:
                editor.document().setDefaultFont(base_font)
            except Exception:
                pass

            # ------------------------------
            if hasattr(editor, 'line_number_area'):
                editor.line_number_area.setFont(base_font)
            # ------------------------------

            # Update existing text formats
            fmt = QtGui.QTextCharFormat()
            fmt.setFontPointSize(new_size)
            cursor = editor.textCursor()
            pos = cursor.position()
            editor.selectAll()
            editor.mergeCurrentCharFormat(fmt)
            editor.setFontPointSize(new_size)
            cursor = editor.textCursor()
            cursor.setPosition(pos)
            editor.setTextCursor(cursor)

            # Update tab width (indent guides)
            try:
                fm = editor.fontMetrics()
                editor.setTabStopDistance(fm.horizontalAdvance(" ") * INDENT_TAB_SIZE)
            except Exception:
                pass

            # Update gutter font (numbers, icons, dots)
            try:
                if hasattr(editor, 'line_number_area'):
                    editor.line_number_area.setFont(base_font)
                editor.update_line_number_area_width()
                editor.update_line_number_area()
                editor.viewport().update()
            except Exception:
                pass

        self.apply_zoom = apply_zoom_value
        
    

        self.zoom_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.zoom_slider.setMinimum(50)
        self.zoom_slider.setMaximum(200)
        self.zoom_slider.setValue(100)
        self.zoom_slider.setFixedWidth(160)
        self.zoom_slider.valueChanged.connect(self.apply_zoom)
        
        bottom_layout = QtWidgets.QHBoxLayout()
        bottom_layout.addWidget(self.status_bar)
        bottom_layout.addWidget(self.autosave_status)
        bottom_layout.addStretch()
        
        # Create a container for zoom controls (keeps them aligned on FAR RIGHT)
        zoom_container = QtWidgets.QHBoxLayout()
        
        self.zoom_minus = HoverButton("-")
        self.zoom_minus.setFixedWidth(22)
        self.zoom_minus.clicked.connect(
            lambda: self.zoom_slider.setValue(self.zoom_slider.value() - 10)
        )
        zoom_container.addWidget(self.zoom_minus)

        self.zoom_plus = HoverButton("+")
        self.zoom_plus.setFixedWidth(22)
        self.zoom_plus.clicked.connect(
            lambda: self.zoom_slider.setValue(self.zoom_slider.value() + 10)
        )
        zoom_container.addWidget(self.zoom_plus)
        zoom_container.addWidget(self.zoom_slider)
        
        # Add the container to the main bottom layout
        bottom_layout.addLayout(zoom_container)

        


        # Main vertical layout
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setMenuBar(self.menu_bar)
        main_layout.addLayout(split_layout)
        main_layout.addLayout(bottom_layout)

        # Connect formatting signals
        self.bold_button.toggled.connect(self.toggle_bold)
        self.italic_button.toggled.connect(self.toggle_italic)
        self.underline_button.toggled.connect(self.toggle_underline)
        self.bullet_button.clicked.connect(self.insert_bullet)
        self.fontsize_combo.currentTextChanged.connect(self.change_fontsize)
        self.color_button.clicked.connect(self.choose_text_color)
        self.highlight_button.clicked.connect(self.choose_highlight_color)
        self.undo_button.clicked.connect(self.edit_undo)
        self.redo_button.clicked.connect(self.edit_redo)
        # Connect bookmark toolbar buttons
        self.bookmark_prev_button.clicked.connect(self.goto_previous_bookmark)
        self.bookmark_next_button.clicked.connect(self.goto_next_bookmark)
        self.bookmark_new_button.clicked.connect(self.toggle_bookmark_current_line)
        self.bookmark_delete_button.clicked.connect(self.clear_bookmark_current_line)
        self.bookmark_list_button.clicked.connect(self.show_bookmark_list)


        # Find panel signal wiring
        self.find_next_button.clicked.connect(self.find_next)
        self.find_prev_button.clicked.connect(self.find_prev)
        self.find_replace_button.clicked.connect(self.find_replace_one)
        self.find_replace_all_button.clicked.connect(self.find_replace_all)
        self.find_close_button.clicked.connect(self.hide_find_panel)
        self.find_input.returnPressed.connect(self.find_next)

        # Create first tab (this will also create the "+" tab)
        self.create_tab("Untitled")

        # Initialize status bar and recent files
        self.update_word_count()
        self.update_recent_files_menu()

    # ------------------------------------------------------------- #
    #  Helpers for "+" tab                                          #
    # ------------------------------------------------------------- #
    def _ensure_plus_tab(self):
        """Make sure the '+' dummy tab exists and is the last tab."""
        if self.plus_tab_dummy is None:
            self.plus_tab_dummy = QtWidgets.QWidget()
            plus_index = self.tab_widget.addTab(self.plus_tab_dummy, "+")
        else:
            plus_index = self.tab_widget.indexOf(self.plus_tab_dummy)
            if plus_index == -1:
                self.plus_tab_dummy = QtWidgets.QWidget()
                plus_index = self.tab_widget.addTab(self.plus_tab_dummy, "+")
        # Remove close button from '+' tab
        bar = self.tab_widget.tabBar()
        for side in (QtWidgets.QTabBar.LeftSide, QtWidgets.QTabBar.RightSide):
            btn = bar.tabButton(plus_index, side)
            if btn is not None:
                btn.hide()
                bar.setTabButton(plus_index, side, None)
        return plus_index

    # ------------------------------------------------------------- #
    #  Event filter (for middle-click tab close)                    #
    # ------------------------------------------------------------- #
    def eventFilter(self, obj, event):
        """Autogenerated stub documentation removed for clarity."""
        tab_bar = self.tab_widget.tabBar()
        if obj == tab_bar and event.type() == QtCore.QEvent.MouseButtonRelease:
            if event.button() == QtCore.Qt.MiddleButton:
                index = tab_bar.tabAt(event.pos())
                if index >= 0:
                    widget = self.tab_widget.widget(index)
                    if widget is self.plus_tab_dummy:
                        return True
                    self.close_tab(index)
                    return True
        return QtWidgets.QWidget.eventFilter(self, obj, event)

    # ------------------------------------------------------------- #
    #  Tab helpers                                                  #
    # ------------------------------------------------------------- #
    def create_tab(self, title="Untitled"):
        """Autogenerated stub documentation removed for clarity."""
        # v8: use AdvancedCodeEditor (inherits PersistentTextEdit)
        editor = AdvancedCodeEditor(self)
        editor.setMinimumHeight(300)
        editor.textChanged.connect(self.on_text_changed)
        editor.textChanged.connect(self.update_word_count)
        editor.emptied.connect(self.on_text_emptied)
        editor.cursorPositionChanged.connect(self.update_bracket_highlight)
        editor.cursorPositionChanged.connect(self.update_word_highlight)

        if self.plus_tab_dummy is None or self.tab_widget.indexOf(self.plus_tab_dummy) == -1:
            # No '+' tab yet: add editor, then '+'.
            index = self.tab_widget.addTab(editor, title)
            self._ensure_plus_tab()
        else:
            # Insert new editor before the '+' tab.
            plus_index = self.tab_widget.indexOf(self.plus_tab_dummy)
            index = self.tab_widget.insertTab(plus_index, editor, title)

        # Apply default formatting and default language
        self.apply_default_formatting(editor)
        editor.highlighter.set_language("text")
        self.apply_gutter_settings(editor)
        # New-tab placeholder (light watermark). Disappears automatically when text exists.
        try:
            editor.set_placeholder("Start typing, or open a file to begin.")
            editor.set_placeholder_color("#5e5e5e")
        except Exception:
            pass


        self.tab_widget.setCurrentIndex(index)
        self.on_tab_changed(index)
        self.update_tab_colors()
        return editor

    def current_editor(self):
        """Autogenerated stub documentation removed for clarity."""
        widget = self.tab_widget.currentWidget()
        if isinstance(widget, QtWidgets.QTextEdit) and widget is not self.plus_tab_dummy:
            return widget
        return None

    def on_tab_changed(self, index):
        """Autogenerated stub documentation removed for clarity."""
        widget = self.tab_widget.widget(index)
        if widget is self.plus_tab_dummy:
            # '+' tab shouldn't update editor state
            return
        if isinstance(widget, QtWidgets.QTextEdit):
            self.current_file_path = getattr(widget, "file_path", None)
            self.is_modified = getattr(widget, "is_modified", False)
        else:
            self.current_file_path = None
            self.is_modified = False
        self.update_word_count()
        self.update_bracket_highlight()
        self.update_word_highlight()
        self.update_tab_colors()

    def close_tab(self, index):
        """Autogenerated stub documentation removed for clarity."""
        if index < 0:
            return
        editor = self.tab_widget.widget(index)
        if editor is self.plus_tab_dummy:
            # Never close the '+' tab
            return

        modified = getattr(editor, "is_modified", False)

        if modified:
            reply = QtWidgets.QMessageBox.question(
                self,
                "Save Changes?",
                "Do you want to save before closing this tab?",
                QtWidgets.QMessageBox.Yes
                | QtWidgets.QMessageBox.No
                | QtWidgets.QMessageBox.Cancel,
                QtWidgets.QMessageBox.Cancel,
            )
            if reply == QtWidgets.QMessageBox.Yes:
                self.tab_widget.setCurrentIndex(index)
                self.save()
            elif reply == QtWidgets.QMessageBox.Cancel:
                return

        self.tab_widget.removeTab(index)

        # Ensure at least one real tab exists (besides '+')
        real_tabs = [
            i for i in range(self.tab_widget.count())
            if self.tab_widget.widget(i) is not self.plus_tab_dummy
        ]
        if not real_tabs:
            self.create_tab("Untitled")
        else:
            self.on_tab_changed(self.tab_widget.currentIndex())

    # ------------------------------------------------------------- #
    #  Advanced tab operations                                      #
    # ------------------------------------------------------------- #
    def on_tab_bar_clicked(self, index):
        """Handle clicks on the tab bar (for '+' tab behaviour)."""
        if index < 0:
            return
        widget = self.tab_widget.widget(index)
        if widget is self.plus_tab_dummy:
            self.new_tab()

    def show_tab_context_menu(self, pos):
        """Autogenerated stub documentation removed for clarity."""
        tab_bar = self.tab_widget.tabBar()
        index = tab_bar.tabAt(pos)
        if index < 0:
            return

        widget = self.tab_widget.widget(index)
        if widget is self.plus_tab_dummy:
            # Right-click on '+' tab: only allow New Tab.
            menu = QtWidgets.QMenu(self)
            new_tab_action = menu.addAction("New Tab")
            action = menu.exec_(tab_bar.mapToGlobal(pos))
            if action == new_tab_action:
                self.new_tab()
            return

        menu = QtWidgets.QMenu(self)

        new_tab_action = menu.addAction("New Tab")
        menu.addSeparator()
        rename_action = menu.addAction("Rename Tab...")
        duplicate_action = menu.addAction("Duplicate Tab")
        menu.addSeparator()
        close_action = menu.addAction("Close Tab")
        close_others_action = menu.addAction("Close Other Tabs")
        close_all_action = menu.addAction("Close All Tabs")

        action = menu.exec_(tab_bar.mapToGlobal(pos))
        if action == new_tab_action:
            self.new_tab()
        elif action == rename_action:
            self.rename_tab(index)
        elif action == duplicate_action:
            self.duplicate_tab(index)
        elif action == close_action:
            self.close_tab(index)
        elif action == close_others_action:
            self.close_other_tabs(index)
        elif action == close_all_action:
            self.close_all_tabs()

    def rename_tab(self, index):
        """Autogenerated stub documentation removed for clarity."""
        if index < 0:
            return
        widget = self.tab_widget.widget(index)
        if widget is self.plus_tab_dummy:
            return
        current_title = self.tab_widget.tabText(index)
        new_title, ok = QtWidgets.QInputDialog.getText(
            self,
            "Rename Tab",
            "New name:",
            text=current_title,
        )
        if ok and new_title.strip():
            self.tab_widget.setTabText(index, new_title.strip())

    def duplicate_tab(self, index):
        """Autogenerated stub documentation removed for clarity."""
        if index < 0:
            return
        editor = self.tab_widget.widget(index)
        if not isinstance(editor, QtWidgets.QTextEdit) or editor is self.plus_tab_dummy:
            return
        text = editor.toPlainText()
        title = self.tab_widget.tabText(index)
        new_title = f"{title} (copy)"

        new_editor = self.create_tab(new_title)
        new_editor.setPlainText(text)
        new_editor.file_path = None  # treat duplicate as a new unsaved document
        new_editor.is_modified = True

    def close_other_tabs(self, keep_index):
        """Autogenerated stub documentation removed for clarity."""
        count = self.tab_widget.count()
        for i in reversed(range(count)):
            if i == keep_index:
                continue
            widget = self.tab_widget.widget(i)
            if widget is self.plus_tab_dummy:
                continue
            self.close_tab(i)

    def close_all_tabs(self):
        """Autogenerated stub documentation removed for clarity."""
        count = self.tab_widget.count()
        for i in reversed(range(count)):
            widget = self.tab_widget.widget(i)
            if widget is self.plus_tab_dummy:
                continue
            self.close_tab(i)

    # ------------------------------------------------------------- #
    #  Utility methods                                              #
    # ------------------------------------------------------------- #
    def clear_bookmark_current_line(self):
        editor = self.current_editor()
        if isinstance(editor, AdvancedCodeEditor):
            editor.clear_bookmark_current_line()

    def show_bookmark_list(self):
        editor = self.current_editor()
        if not isinstance(editor, AdvancedCodeEditor):
            return
        bm = getattr(editor, "bookmarked_lines", {})
        if not bm:
            QtWidgets.QMessageBox.information(self, "Bookmarks", "No bookmarks in this document.")
            return

        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Bookmarks")
        dialog.setModal(True)
        layout = QtWidgets.QVBoxLayout(dialog)

        list_widget = QtWidgets.QListWidget()
        doc = editor.document()
        palette = getattr(editor, "bookmark_palette", [])
        for line_num in sorted(bm.keys()):
            block = doc.findBlockByNumber(line_num)
            text = block.text().strip()
            if not text:
                text = "<empty line>"
            item_text = f"Line {line_num+1}: {text}"
            item = QtWidgets.QListWidgetItem(item_text)
            idx = bm.get(line_num, 0)
            if palette:
                color = palette[idx % len(palette)]
                item.setForeground(color)
            list_widget.addItem(item)

        def on_item_activated(item):
            row = list_widget.row(item)
            sorted_lines = sorted(bm.keys())
            if 0 <= row < len(sorted_lines):
                target_line = sorted_lines[row]
                editor._goto_bookmark_line(target_line)
            dialog.accept()

        list_widget.itemDoubleClicked.connect(on_item_activated)
        layout.addWidget(list_widget)

        button_box = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Close)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        dialog.resize(420, 260)
        dialog.exec_()

    def toggle_bookmark_current_line(self):
        editor = self.current_editor()
        if isinstance(editor, AdvancedCodeEditor):
            editor.toggle_bookmark_current_line()

    def goto_next_bookmark(self):
        editor = self.current_editor()
        if isinstance(editor, AdvancedCodeEditor):
            editor.goto_next_bookmark()

    def goto_previous_bookmark(self):
        editor = self.current_editor()
        if isinstance(editor, AdvancedCodeEditor):
            editor.goto_previous_bookmark()

    def update_word_count(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            self.status_bar.setText("Words: 0 | Characters: 0")
            return
        text = editor.toPlainText()
        words = len(text.split())
        chars = len(text)
        self.status_bar.setText(f"Words: {words} | Characters: {chars}")

    def add_recent_file(self, path):
        """Autogenerated stub documentation removed for clarity."""
        if path not in self.recent_files:
            self.recent_files.insert(0, path)
        self.recent_files = self.recent_files[: self.MAX_RECENT_FILES]
        self.update_recent_files_menu()

    def update_recent_files_menu(self):
        """Autogenerated stub documentation removed for clarity."""
        self.recent_menu_bar.clear()
        if not self.recent_files:
            self.recent_menu_bar.addAction("(No Recent Files)").setEnabled(False)
        else:
            for path in self.recent_files:
                action = self.recent_menu_bar.addAction(path)
                action.triggered.connect(
                    lambda checked=False, p=path: self.load_file_from_browser(p)
                )

    def apply_gutter_settings(self, editor=None):
        """Apply global gutter settings to a given editor."""
        if editor is None:
            editor = self.current_editor()
        if not isinstance(editor, AdvancedCodeEditor):
            return
        editor.show_line_numbers = self.gutter_show_line_numbers
        editor.show_fold_markers = self.gutter_show_fold_markers
        editor.gutter_scale = self.gutter_scale
        editor.fold_icon_style = self.gutter_icon_style
        editor.update_line_number_area_width()
        editor.update_line_number_area()

    def show_gutter_settings(self):
        """Open a small dialog to configure gutter appearance."""
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Gutter Settings")
        dlg.setModal(True)
        dlg.setStyleSheet(
            "QDialog { background-color: #2c2c2c; color: #dddddd; }"
            "QCheckBox, QLabel { color: #dddddd; }"
        )

        layout = QtWidgets.QVBoxLayout(dlg)

        cb_numbers = QtWidgets.QCheckBox("Show line numbers")
        cb_numbers.setChecked(self.gutter_show_line_numbers)
        cb_folds = QtWidgets.QCheckBox("Show fold markers")
        cb_folds.setChecked(self.gutter_show_fold_markers)

        size_layout = QtWidgets.QHBoxLayout()
        size_label = QtWidgets.QLabel("Gutter size:")
        size_value_label = QtWidgets.QLabel(f"{int(self.gutter_scale * 100)}%")
        size_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        size_slider.setMinimum(80)
        size_slider.setMaximum(200)
        size_slider.setValue(int(self.gutter_scale * 100))

        def on_slider_change(val):
            size_value_label.setText(f"{val}%")

        size_slider.valueChanged.connect(on_slider_change)

        size_layout.addWidget(size_label)
        size_layout.addWidget(size_slider)
        size_layout.addWidget(size_value_label)

        icon_label = QtWidgets.QLabel("Fold icon style:")
        icon_combo = QtWidgets.QComboBox()
        icon_combo.addItems(["Triangles (VSCode style)"])
        icon_combo.setCurrentIndex(0)

        layout.addWidget(cb_numbers)
        layout.addWidget(cb_folds)
        layout.addLayout(size_layout)
        layout.addWidget(icon_label)
        layout.addWidget(icon_combo)

        buttons = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
        )
        layout.addWidget(buttons)

        buttons.accepted.connect(dlg.accept)
        buttons.rejected.connect(dlg.reject)

        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            self.gutter_show_line_numbers = cb_numbers.isChecked()
            self.gutter_show_fold_markers = cb_folds.isChecked()
            self.gutter_scale = size_slider.value() / 100.0

            for i in range(self.tab_widget.count()):
                editor = self.tab_widget.widget(i)
                if isinstance(editor, AdvancedCodeEditor):
                    self.apply_gutter_settings(editor)
    def show_find_replace(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        self.find_panel.setVisible(True)
        self.find_input.setFocus()
        self.find_input.selectAll()

    # ------------------------------------------------------------- #
    #  Find panel helpers                                           #
    # ------------------------------------------------------------- #
    def hide_find_panel(self):
        """Autogenerated stub documentation removed for clarity."""
        self.find_panel.setVisible(False)

    def _current_doc(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return None, None
        return editor, editor.document()

    def find_next(self):
        """Autogenerated stub documentation removed for clarity."""
        editor, doc = self._current_doc()
        if not editor or not doc:
            return
        pattern = self.find_input.text()
        if not pattern:
            return

        flags = QtGui.QTextDocument.FindFlags()
        if self.find_case_checkbox.isChecked():
            flags |= QtGui.QTextDocument.FindCaseSensitively

        cursor = editor.textCursor()

        # Regex or plain text search
        if self.find_regex_checkbox.isChecked():
            try:
                regex = QtCore.QRegularExpression(pattern)
            except Exception:
                return
            found = doc.find(regex, cursor, flags)
        else:
            found = doc.find(pattern, cursor, flags)

        # Wrap search to start if nothing after cursor
        if (not found) or found.isNull():
            start_cursor = QtGui.QTextCursor(doc)
            if self.find_regex_checkbox.isChecked():
                regex = QtCore.QRegularExpression(pattern)
                found = doc.find(regex, start_cursor, flags)
            else:
                found = doc.find(pattern, start_cursor, flags)

        if found and not found.isNull():
            editor.setTextCursor(found)

    def find_prev(self):
        """Autogenerated stub documentation removed for clarity."""
        editor, doc = self._current_doc()
        if not editor or not doc:
            return
        pattern = self.find_input.text()
        if not pattern:
            return

        flags = QtGui.QTextDocument.FindBackward
        if self.find_case_checkbox.isChecked():
            flags |= QtGui.QTextDocument.FindCaseSensitively

        cursor = editor.textCursor()

        if self.find_regex_checkbox.isChecked():
            try:
                regex = QtCore.QRegularExpression(pattern)
            except Exception:
                return
            found = doc.find(regex, cursor, flags)
        else:
            found = doc.find(pattern, cursor, flags)

        if found and not found.isNull():
            editor.setTextCursor(found)

    def find_replace_one(self):
        """Autogenerated stub documentation removed for clarity."""
        editor, doc = self._current_doc()
        if not editor or not doc:
            return
        cursor = editor.textCursor()
        if cursor.hasSelection():
            cursor.insertText(self.replace_input.text())
        self.find_next()

    def find_replace_all(self):
        """Autogenerated stub documentation removed for clarity."""
        editor, doc = self._current_doc()
        if not editor or not doc:
            return
        pattern = self.find_input.text()
        if not pattern:
            return
        replace_text = self.replace_input.text()

        flags = QtGui.QTextDocument.FindFlags()
        if self.find_case_checkbox.isChecked():
            flags |= QtGui.QTextDocument.FindCaseSensitively

        cursor = QtGui.QTextCursor(doc)
        cursor.beginEditBlock()
        while True:
            if self.find_regex_checkbox.isChecked():
                regex = QtCore.QRegularExpression(pattern)
                found = doc.find(regex, cursor, flags)
            else:
                found = doc.find(pattern, cursor, flags)
            if (not found) or found.isNull():
                break
            found.insertText(replace_text)
            cursor = found
        cursor.endEditBlock()

    # ------------------------------------------------------------- #
    #  Autosave helpers (Mode C: idle + interval, silent)           #
    # ------------------------------------------------------------- #


    # ------------------------------------------------------------- #
    #  Bookmark persistence helpers (per-file .bookmarks.json)       #
    # ------------------------------------------------------------- #
    def _bookmark_sidecar_path(self, path):
        """Return sidecar path used to store bookmarks for a file."""
        try:
            return path + ".bookmarks.json"
        except Exception:
            return None

    def _load_bookmarks_for_editor(self, editor):
        """Load bookmarks from a sidecar JSON file into the given editor."""
        from types import MappingProxyType  # avoid Py2 issues if any
        if not isinstance(editor, AdvancedCodeEditor):
            return
        path = getattr(editor, "file_path", None)
        if not path:
            return
        sidecar = self._bookmark_sidecar_path(path)
        if not sidecar or not os.path.exists(sidecar):
            return
        try:
            with io.open(sidecar, "r", encoding="utf-8") as f:
                data = json.loads(f.read())
        except Exception:
            return
        bookmarks = data.get("bookmarks", [])
        if not isinstance(bookmarks, list):
            return
        bm = {}
        for item in bookmarks:
            try:
                line = int(item.get("line", -1))
                color = int(item.get("color", 0))
            except Exception:
                continue
            if line >= 0:
                bm[line] = color
        editor.bookmarked_lines = bm
        try:
            editor.update_line_number_area()
        except Exception:
            pass

    def _save_bookmarks_for_editor(self, editor):
        """Save bookmarks from the given editor into a sidecar JSON file."""
        if not isinstance(editor, AdvancedCodeEditor):
            return
        path = getattr(editor, "file_path", None)
        if not path:
            return
        bm = getattr(editor, "bookmarked_lines", {})
        # Normalize to dict of int -> int
        items = []
        if isinstance(bm, dict):
            for line, color in sorted(bm.items()):
                try:
                    items.append({"line": int(line), "color": int(color)})
                except Exception:
                    continue
        data = {"bookmarks": items}
        sidecar = self._bookmark_sidecar_path(path)
        if not sidecar:
            return
        try:
            with io.open(sidecar, "w", encoding="utf-8") as f:
                f.write(json.dumps(data))
        except Exception:
            # Silent failure is fine; bookmarks are non-critical.
            pass

    def _recovery_path(self):
        """Return path to crash recovery file."""
        home = os.path.expanduser("~")
        return os.path.join(home, ".nuke_text_editor_recovery.json")

    def save_session_backup(self):
        """Save a lightweight snapshot of the current session for crash recovery."""
        try:
            tabs_data = []
            for i in range(self.tab_widget.count()):
                editor = self.tab_widget.widget(i)
                if not isinstance(editor, QtWidgets.QTextEdit) or editor is self.plus_tab_dummy:
                    continue
                path = getattr(editor, "file_path", None)
                text = editor.toPlainText()
                title = self.tab_widget.tabText(i)
                is_modified = getattr(editor, "is_modified", False)
                tabs_data.append({
                    "title": title,
                    "file_path": path,
                    "text": text,
                    "is_modified": is_modified,
                })
            data = {
                "tabs": tabs_data,
                "current_index": self.tab_widget.currentIndex(),
            }
            backup_path = self._recovery_path()
            with io.open(backup_path, "w", encoding="utf-8") as f:
                f.write(json.dumps(data))
        except Exception:
            pass

    def _restore_session_if_any(self):
        """Restore a previous session from crash recovery file, if present."""
        backup_path = self._recovery_path()
        if not os.path.exists(backup_path):
            return

        try:
            with io.open(backup_path, "r", encoding="utf-8") as f:
                data = json.loads(f.read())
        except Exception:
            return

        if not isinstance(data, dict) or "tabs" not in data:
            return

        reply = QtWidgets.QMessageBox.question(
            self,
            "Restore Session",
            "A previous editor session was found. Restore it?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes,
        )
        if reply != QtWidgets.QMessageBox.Yes:
            try:
                os.remove(backup_path)
            except Exception:
                pass
            return

        # Clear existing tabs quickly (without prompts)
        for i in reversed(range(self.tab_widget.count())):
            self.tab_widget.removeTab(i)
        self.plus_tab_dummy = None

        # Recreate tabs
        tabs = data.get("tabs", [])
        for t in tabs:
            title = t.get("title") or "Untitled"
            path = t.get("file_path")
            text = t.get("text") or ""
            is_modified = bool(t.get("is_modified", False))

            editor = self.create_tab(title)
            editor.setPlainText(text)
            editor.file_path = path
            editor.is_modified = is_modified
            self._apply_language_for_editor(editor)

        # Restore current index
        idx = data.get("current_index", 0)
        if 0 <= idx < self.tab_widget.count():
            self.tab_widget.setCurrentIndex(idx)

        try:
            os.remove(backup_path)
        except Exception:
            pass

    def update_autosave_status_label(self):
        """Update the bottom-bar autosave status text."""
        try:
            enabled = bool(getattr(self, "autosave_enabled", True))
            self.autosave_status.setText(f"Autosave: {'On' if enabled else 'Off'}")
        except Exception:
            pass

    def set_autosave_enabled(self, enabled):
        """Enable/disable autosave snapshots without affecting other features."""
        self.autosave_enabled = bool(enabled)
        self.update_autosave_status_label()
        # Keep menu check state in sync if it exists
        try:
            if hasattr(self, "autosave_toggle_action"):
                self.autosave_toggle_action.setChecked(self.autosave_enabled)
        except Exception:
            pass

    def show_autosave_history(self):
        """Open the autosave history dialog for the current tab."""
        dlg = AutosaveHistoryDialog(self, self)
        dlg.exec_() if hasattr(dlg, "exec_") else dlg.exec()

    def show_autosave_settings(self):
        """Open autosave settings dialog."""
        dlg = AutosaveSettingsDialog(self, self)
        dlg.exec_() if hasattr(dlg, "exec_") else dlg.exec()

    def _autosave_safe_key(self, editor):
        """Return a stable folder key for an editor (file-based or tab-based)."""
        path = getattr(editor, "file_path", None)
        if path:
            try:
                h = hashlib.sha1(path.encode("utf-8", errors="ignore")).hexdigest()[:10]
            except Exception:
                h = "0000000000"
            base = os.path.basename(path) or "file"
            base = re.sub(r"[^A-Za-z0-9._-]+", "_", base)
            return f"{base}_{h}"
        # Unsaved tab: use per-tab autosave_id
        tab_id = getattr(editor, "autosave_id", "untitled")
        return f"untitled_{str(tab_id)[:10]}"

    def _autosave_dir_for_editor(self, editor):
        key = self._autosave_safe_key(editor)
        folder = os.path.join(getattr(self, "autosave_root", ""), key)
        try:
            os.makedirs(folder, exist_ok=True)
        except Exception:
            pass
        return folder

    def _write_autosave_snapshot(self, editor):
        """Write a snapshot for this editor and prune old versions."""
        folder = self._autosave_dir_for_editor(editor)
        if not folder:
            return

        ts = time.strftime("%Y%m%d_%H%M%S")
        snap_path = os.path.join(folder, f"{ts}.txt")
        meta_path = os.path.join(folder, f"{ts}.json")

        try:
            with io.open(snap_path, "w", encoding="utf-8") as f:
                f.write(editor.toPlainText())
        except Exception:
            return

        # Save tiny metadata (best-effort)
        try:
            tab_title = self.tab_widget.tabText(self.tab_widget.indexOf(editor)).replace(" ", "")
        except Exception:
            tab_title = "Untitled"
        meta = {
            "timestamp": ts,
            "tab_title": tab_title,
            "file_path": getattr(editor, "file_path", None),
        }
        try:
            with io.open(meta_path, "w", encoding="utf-8") as f:
                f.write(json.dumps(meta, indent=2))
        except Exception:
            pass

        # Prune old versions (keep newest N)
        try:
            snaps = [p for p in os.listdir(folder) if p.lower().endswith(".txt")]
            snaps.sort()
            max_keep = int(getattr(self, "autosave_max_versions", 20))
            if len(snaps) > max_keep:
                for old in snaps[: max(0, len(snaps) - max_keep)]:
                    try:
                        os.remove(os.path.join(folder, old))
                    except Exception:
                        pass
                    # delete matching json
                    try:
                        j = os.path.splitext(old)[0] + ".json"
                        jp = os.path.join(folder, j)
                        if os.path.exists(jp):
                            os.remove(jp)
                    except Exception:
                        pass
        except Exception:
            pass

    def list_autosave_snapshots(self, editor):
        """Return a list of snapshot dicts for an editor (newest first)."""
        folder = self._autosave_dir_for_editor(editor)
        out = []
        try:
            items = [p for p in os.listdir(folder) if p.lower().endswith(".txt")]
            items.sort(reverse=True)
            for fn in items:
                p = os.path.join(folder, fn)
                ts = os.path.splitext(fn)[0]
                meta_p = os.path.join(folder, ts + ".json")
                try:
                    size_kb = int(os.path.getsize(p) / 1024)
                except Exception:
                    size_kb = 0
                # Human timestamp
                try:
                    dt = datetime.datetime.strptime(ts, "%Y%m%d_%H%M%S")
                    human = dt.strftime("%Y-%m-%d %H:%M:%S")
                except Exception:
                    human = ts
                out.append({
                    "path": p,
                    "meta_path": meta_p,
                    "timestamp": ts,
                    "timestamp_human": human,
                    "size_kb": size_kb,
                })
        except Exception:
            pass
        return out

    def restore_snapshot_into_current_tab(self, content):
        """Restore snapshot content into the current tab (marks modified)."""
        editor = self.current_editor()
        if not editor:
            return
        try:
            editor.setPlainText(content)
            editor.is_modified = True
            self.is_modified = True
            self.update_tab_colors()
            self.update_word_count()
        except Exception:
            pass

    def open_snapshot_as_new_tab(self, content):
        """Open snapshot content in a new tab (safe restore option)."""
        try:
            new_editor = self.create_tab("Autosave")
            new_editor.setPlainText(content)
            new_editor.file_path = None
            new_editor.is_modified = True
            self.update_tab_colors()
        except Exception:
            pass

    def handle_autosave(self):
        """Timer handler. Creates snapshot files when enabled."""
        if not bool(getattr(self, "autosave_enabled", True)):
            return

        now = QtCore.QDateTime.currentDateTime()

        # Only autosave if the user has been idle long enough
        if self.last_edit_time.msecsTo(now) >= self.autosave_idle_ms:
            self.autosave_all()
            self.last_edit_time = now
            self.last_autosave_time = now
            return

        # Safety net: interval autosave
        if self.last_autosave_time.msecsTo(now) >= self.autosave_interval_ms:
            self.autosave_all()
            self.last_autosave_time = now

    def autosave_all(self):
        """Create autosave snapshots for all modified tabs (no overwrite)."""
        if not hasattr(self, "tab_widget"):
            return

        for index in range(self.tab_widget.count()):
            editor = self.tab_widget.widget(index)
            if not isinstance(editor, QtWidgets.QTextEdit):
                continue
            if editor is getattr(self, "plus_tab_dummy", None):
                continue

            modified = getattr(editor, "is_modified", False)
            if not modified:
                continue

            # Do not autosave empty documents
            try:
                if editor.toPlainText().strip() == "":
                    continue
            except Exception:
                continue

            self._write_autosave_snapshot(editor)

        # Keep crash-recovery snaps (existing feature)
        try:
            self.save_session_backup()
        except Exception:
            pass

    # ------------------------------------------------------------- #
    #  Word highlight helper (smart word matching)                  #
    # ------------------------------------------------------------- #
    def update_word_highlight(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return

        doc = editor.document()
        cursor = editor.textCursor()
        cursor.select(QtGui.QTextCursor.WordUnderCursor)
        word = cursor.selectedText()

        WORD_PROP_KEY = 1001

        # Start from existing selections (e.g. bracket highlights) and
        # strip any previous word-highlight formats that we added before.
        base_selections = []
        for sel in editor.extraSelections():
            fmt = sel.format
            try:
                has_prop = fmt.property(WORD_PROP_KEY)
            except Exception:
                has_prop = None
            if not has_prop:
                base_selections.append(sel)

        # Add current line highlight (full width)
        line_sel = QtWidgets.QTextEdit.ExtraSelection()
        line_cursor = editor.textCursor()
        line_cursor.clearSelection()
        line_sel.cursor = line_cursor
        line_fmt = QtGui.QTextCharFormat()
        line_fmt.setBackground(QtGui.QColor("#2a2a30"))
        line_fmt.setProperty(QtGui.QTextFormat.FullWidthSelection, True)
        line_sel.format = line_fmt
        base_selections.append(line_sel)

        # Determine if this is a "real" word we care about.
        if not word or not word.strip():
            editor.setExtraSelections(base_selections)
            return
        if len(word) < 2:
            editor.setExtraSelections(base_selections)
            return
        if not any(ch.isalnum() for ch in word):
            editor.setExtraSelections(base_selections)
            return

        # Build a whole-word, case-sensitive regex for the word.
        pattern = r"\b" + re.escape(word) + r"\b"
        regex = QtCore.QRegularExpression(pattern)

        text = doc.toPlainText()
        it = regex.globalMatch(text)

        highlights = []
        active_start = cursor.selectionStart()
        active_end = cursor.selectionEnd()

        # Main and secondary highlight formats (Dracula style)
        main_fmt = QtGui.QTextCharFormat()
        main_fmt.setBackground(QtGui.QColor("#44475a"))
        main_fmt.setProperty(WORD_PROP_KEY, True)

        other_fmt = QtGui.QTextCharFormat()
        other_fmt.setBackground(QtGui.QColor("#3a3c4e"))
        other_fmt.setProperty(WORD_PROP_KEY, True)

        while it.hasNext():
            match = it.next()
            start_pos = match.capturedStart()
            end_pos = match.capturedEnd()
            if start_pos < 0 or end_pos <= start_pos:
                continue

            c = QtGui.QTextCursor(doc)
            c.setPosition(start_pos)
            c.setPosition(end_pos, QtGui.QTextCursor.KeepAnchor)

            sel = QtWidgets.QTextEdit.ExtraSelection()
            sel.cursor = c
            # Active word uses main_fmt; others use other_fmt.
            if start_pos == active_start and end_pos == active_end:
                sel.format = main_fmt
            else:
                sel.format = other_fmt
            highlights.append(sel)

        # If there is only one occurrence (the current word), do not highlight at all.
        if len(highlights) <= 1:
            editor.setExtraSelections(base_selections)
            return

        editor.setExtraSelections(base_selections + highlights)

    # ------------------------------------------------------------- #
    #  Bracket matching and tab color helpers                       #
    # ------------------------------------------------------------- #
    def update_bracket_highlight(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        text = editor.toPlainText()
        cursor = editor.textCursor()
        pos = cursor.position()
        if not text:
            editor.setExtraSelections([])
            return

        brackets = {"(": ")", "[": "]", "{": "}", ")": "(", "]": "[", "}": "{"}
        opening = "([{"
        closing = ")]}"

        def match_pos(start_index, forward):
            """Autogenerated stub documentation removed for clarity."""
            stack = 0
            step = 1 if forward else -1
            i = start_index
            while 0 <= i < len(text):
                ch = text[i]
                if ch == ch_open:
                    stack += 1
                elif ch == ch_close:
                    stack -= 1
                    if stack == 0:
                        return i
                i += step
            return -1

        # Determine the bracket under or next to the cursor
        if pos > 0 and text[pos - 1] in brackets:
            ch = text[pos - 1]
            idx = pos - 1
        elif pos < len(text) and text[pos] in brackets:
            ch = text[pos]
            idx = pos
        else:
            # No bracket at cursor: clear any previous selection
            editor.setExtraSelections([])
            return

        ch_match = brackets[ch]
        if ch in opening:
            ch_open, ch_close = ch, ch_match
            partner_index = match_pos(idx, True)
        else:
            ch_open, ch_close = ch_match, ch
            partner_index = match_pos(idx, False)

        selections = []
        # Format for a valid bracket pair
        pair_fmt = QtGui.QTextCharFormat()
        pair_fmt.setBackground(QtGui.QColor("#44475a"))

        # Format for an unmatched / error bracket
        error_fmt = QtGui.QTextCharFormat()
        error_fmt.setBackground(QtGui.QColor("#ff5555"))

        if partner_index == -1:
            # Unmatched bracket -> highlight the single one in red
            c = QtGui.QTextCursor(editor.document())
            c.setPosition(idx)
            c.movePosition(QtGui.QTextCursor.NextCharacter, QtGui.QTextCursor.KeepAnchor)
            sel = QtWidgets.QTextEdit.ExtraSelection()
            sel.cursor = c
            sel.format = error_fmt
            selections.append(sel)
            editor.setExtraSelections(selections)
            return

        # Valid pair -> highlight both
        for i in (idx, partner_index):
            c = QtGui.QTextCursor(editor.document())
            c.setPosition(i)
            c.movePosition(QtGui.QTextCursor.NextCharacter, QtGui.QTextCursor.KeepAnchor)
            sel = QtWidgets.QTextEdit.ExtraSelection()
            sel.cursor = c
            sel.format = pair_fmt
            selections.append(sel)

        editor.setExtraSelections(selections)

    def update_tab_colors(self):
        """Autogenerated stub documentation removed for clarity."""
        tab_bar = self.tab_widget.tabBar()
        for index in range(self.tab_widget.count()):
            widget = self.tab_widget.widget(index)
            if widget is self.plus_tab_dummy:
                continue
            editor = widget
            path = getattr(editor, "file_path", None)
            if not path:
                color = FILETYPE_TAB_COLORS.get("text")
                base = "Untitled"
            else:
                ext = os.path.splitext(path)[1].lower()
                lang = EXTENSION_LANGUAGE.get(ext, "text")
                color = FILETYPE_TAB_COLORS.get(lang, FILETYPE_TAB_COLORS.get("text"))
                base = os.path.basename(path)
            # append unsaved dot
            if getattr(editor, "is_modified", False):
                label = base + " "
            else:
                label = base
            self.tab_widget.setTabText(index, label)
            tab_bar.setTabTextColor(index, color)

    # ------------------------------------------------------------- #
    #  Core text & formatting methods                               #
    # ------------------------------------------------------------- #
    def apply_default_formatting(self, editor=None):
        """Autogenerated stub documentation removed for clarity."""
        if editor is None:
            editor = self.current_editor()
        if not editor:
            return
        fmt = QtGui.QTextCharFormat()
        fmt.setFont(QtGui.QFont(self.DEFAULT_FONT_FAMILY, self.DEFAULT_FONT_SIZE))
        fmt.setForeground(QtGui.QBrush(QtGui.QColor("#e6e6e6")))
        fmt.setBackground(QtGui.QBrush(QtGui.QColor("#1e1e1e")))
        editor.setCurrentCharFormat(fmt)
        editor.document().setDefaultFont(
            QtGui.QFont(self.DEFAULT_FONT_FAMILY, self.DEFAULT_FONT_SIZE)
        )

        try:
            fm = editor.fontMetrics()
            editor.setTabStopDistance(fm.horizontalAdvance(" ") * INDENT_TAB_SIZE)
        except Exception:
            pass

    def on_text_emptied(self):
        """Autogenerated stub documentation removed for clarity."""
        sender = self.sender()
        if isinstance(sender, QtWidgets.QTextEdit):
            self.apply_default_formatting(sender)

    def toggle_sidebar(self):
        """Autogenerated stub documentation removed for clarity."""
        visible = not self.file_browser.isVisible()
        self.file_browser.setVisible(visible)

    def on_text_changed(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        # Mark modified flags on both the editor and the window
        editor.is_modified = True
        self.is_modified = True
        self.current_file_path = getattr(editor, "file_path", None)
        # Update autosave idle timestamp and live highlights
        self.last_edit_time = QtCore.QDateTime.currentDateTime()
        self.update_bracket_highlight()
        self.update_word_highlight()

    def change_alignment(self, index):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        if index == 0:
            editor.setAlignment(QtCore.Qt.AlignLeft)
        elif index == 1:
            editor.setAlignment(QtCore.Qt.AlignCenter)
        elif index == 2:
            editor.setAlignment(QtCore.Qt.AlignRight)
        elif index == 3:
            editor.setAlignment(QtCore.Qt.AlignJustify)

    # ------------------------------------------------------------- #
    #  File helper functions (encoding-safe)                        #
    # ------------------------------------------------------------- #
    def _read_text_file(self, path):
        """Read a text file using UTF-8, compatible with Py2/Py3."""
        return io.open(path, "r", encoding="utf-8")

    def _write_text_file(self, path):
        """Write a text file using UTF-8, compatible with Py2/Py3."""
        return io.open(path, "w", encoding="utf-8")

    def _apply_language_for_editor(self, editor):
        """Set syntax language based on editor.file_path."""
        if not isinstance(editor, PersistentTextEdit):
            return
        path = getattr(editor, "file_path", None)
        if not path:
            editor.highlighter.set_language("text")
            return
        ext = os.path.splitext(path)[1].lower()
        language = EXTENSION_LANGUAGE.get(ext, "text")
        editor.highlighter.set_language(language)

    # ------------------------------------------------------------- #
    #  File operations                                              #
    # ------------------------------------------------------------- #
    def new_tab(self):
        """Autogenerated stub documentation removed for clarity."""
        self.create_tab("Untitled")

    def new_file(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        if getattr(editor, "is_modified", False):
            reply = QtWidgets.QMessageBox.question(
                self,
                "Save Changes?",
                "Do you want to save before creating a new file?",
                QtWidgets.QMessageBox.Yes
                | QtWidgets.QMessageBox.No
                | QtWidgets.QMessageBox.Cancel,
                QtWidgets.QMessageBox.Cancel,
            )
            if reply == QtWidgets.QMessageBox.Yes:
                self.save()
            elif reply == QtWidgets.QMessageBox.Cancel:
                return

        editor.clear()
        editor.file_path = None
        editor.is_modified = False
        self.is_modified = False
        self.current_file_path = None
        self.bold_button.setChecked(False)
        self.italic_button.setChecked(False)
        self.underline_button.setChecked(False)
        self.apply_default_formatting(editor)
        editor.highlighter.set_language("text")

        index = self.tab_widget.indexOf(editor)
        if index >= 0:
            self.tab_widget.setTabText(index, "Untitled")

        self.update_word_count()

    def load_file_from_browser(self, path):
        """Always open browser-selected files in a new tab."""
        editor = self.create_tab(os.path.basename(path))
        try:
            with self._read_text_file(path) as f:
                editor.setPlainText(f.read())

            editor.file_path = path
            editor.is_modified = False
            self.current_file_path = path
            self.is_modified = False
            self.add_recent_file(path)
            self._apply_language_for_editor(editor)
            self._load_bookmarks_for_editor(editor)

            index = self.tab_widget.indexOf(editor)
            if index >= 0:
                self.tab_widget.setTabText(index, os.path.basename(path))

            self.update_word_count()
            self.update_tab_colors()
        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self, "Error", "Could not open file:\n{}".format(e)
            )

    def save(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return

        path = getattr(editor, "file_path", None)

        if path:
            try:
                with self._write_text_file(path) as f:
                    f.write(editor.toPlainText())
                self.add_recent_file(path)
                self._save_bookmarks_for_editor(editor)
                editor.is_modified = False
                self.is_modified = False
                self.current_file_path = path
                # Refresh tab labels after saving (clear unsaved dot)
                self.update_tab_colors()
            except Exception as e:
                QtWidgets.QMessageBox.warning(
                    self, "Error", "Could not save file:\n{}".format(e)
                )
        else:
            self.save_as()

    def save_as(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, "Save As", "", "Text Files (*.txt);;All Files (*)"
        )
        if path:
            if not path.lower().endswith(".txt"):
                path += ".txt"
            try:
                with self._write_text_file(path) as f:
                    f.write(editor.toPlainText())

                editor.file_path = path
                self._save_bookmarks_for_editor(editor)
                editor.is_modified = False
                self.current_file_path = path
                self.is_modified = False
                self.add_recent_file(path)
                self._apply_language_for_editor(editor)

                index = self.tab_widget.indexOf(editor)
                if index >= 0:
                    self.tab_widget.setTabText(index, os.path.basename(path))
                self.update_tab_colors()
            except Exception as e:
                QtWidgets.QMessageBox.warning(
                    self, "Error", "Could not save file\n{}".format(e)
                )

    def open(self):
        """Autogenerated stub documentation removed for clarity."""
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Open File")
        if filename:
            editor = self.create_tab(os.path.basename(filename))
            try:
                with self._read_text_file(filename) as f:
                    editor.setPlainText(f.read())

                editor.file_path = filename
                editor.is_modified = False
                self.current_file_path = filename
                self.is_modified = False
                self.add_recent_file(filename)
                self._apply_language_for_editor(editor)
                self._load_bookmarks_for_editor(editor)

                index = self.tab_widget.indexOf(editor)
                if index >= 0:
                    self.tab_widget.setTabText(index, os.path.basename(filename))

                self.update_word_count()
                self.update_tab_colors()
            except Exception as e:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Error",
                    f"Failed to open file:\n{filename}\n\n{e}",
                )
            except Exception as e:
                QtWidgets.QMessageBox.warning(
                    self, "Error", "Could not open file:\n{}".format(e)
                )

    # ------------------------------------------------------------- #
    #  Formatting / About / Close                                   #
    # ------------------------------------------------------------- #
    def preview_font(self, font):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = QtGui.QTextCharFormat()
        fmt.setFontFamily(font.family())
        editor.mergeCurrentCharFormat(fmt)

    def change_fontsize(self, size_str):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = QtGui.QTextCharFormat()
        fmt.setFontPointSize(int(size_str))
        editor.mergeCurrentCharFormat(fmt)

    def change_fontfamily(self, font):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = QtGui.QTextCharFormat()
        fmt.setFontFamily(font.family())
        editor.mergeCurrentCharFormat(fmt)

    def toggle_bold(self, checked):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = editor.currentCharFormat()
        fmt.setFontWeight(QtGui.QFont.Bold if checked else QtGui.QFont.Normal)
        editor.mergeCurrentCharFormat(fmt)

    def toggle_italic(self, checked):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = editor.currentCharFormat()
        fmt.setFontItalic(checked)
        editor.mergeCurrentCharFormat(fmt)

    def toggle_underline(self, checked):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        fmt = editor.currentCharFormat()
        fmt.setFontUnderline(checked)
        editor.mergeCurrentCharFormat(fmt)

    def choose_text_color(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        color = QtWidgets.QColorDialog.getColor()
        if color.isValid():
            fmt = editor.currentCharFormat()
            fmt.setForeground(QtGui.QBrush(color))
            editor.mergeCurrentCharFormat(fmt)

    def choose_highlight_color(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        color = QtWidgets.QColorDialog.getColor()
        if color.isValid():
            fmt = editor.currentCharFormat()
            fmt.setBackground(QtGui.QBrush(color))
            editor.mergeCurrentCharFormat(fmt)

    def edit_undo(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if editor:
            editor.undo()

    def edit_redo(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if editor:
            editor.redo()

    def insert_bullet(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        cursor = editor.textCursor()
        cursor.insertText(" ")
        editor.setTextCursor(cursor)


    def send_selection_to_sticky(self):
        """Create a StickyNote node in the DAG with the current selection text."""
        editor = self.current_editor()
        if not editor:
            return
        text = editor.textCursor().selectedText()
        if not text:
            return
        try:
            n = nuke.createNode("StickyNote")
            n["label"].setValue(text)
        except Exception:
            pass

    def send_selection_to_python_node(self):
        """Create a Python Script node in the DAG with the current selection as code."""
        editor = self.current_editor()
        if not editor:
            return
        text = editor.textCursor().selectedText()
        if not text:
            return
        try:
            n = nuke.createNode("Python")
            knob = n.knob("command") or n.knob("script") or n.knob("Python")
            if knob is not None:
                knob.setValue(text)
        except Exception:
            pass

    def toggle_word_wrap(self):
        """Autogenerated stub documentation removed for clarity."""
        editor = self.current_editor()
        if not editor:
            return
        mode = editor.lineWrapMode()
        if mode == QtWidgets.QTextEdit.NoWrap:
            editor.setLineWrapMode(QtWidgets.QTextEdit.WidgetWidth)
        else:
            editor.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)

    def show_about(self):
        """Autogenerated stub documentation removed for clarity."""
        msg = QtWidgets.QMessageBox(self)
        msg.setWindowTitle("About")
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setTextFormat(QtCore.Qt.RichText)
        msg.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.setText(
            """Nuke Text Editor<br>Pedro Gartner<br>
        <a href='https://github.com/PedroGartner' style='text-decoration: underline; color: #ffffff;'>GitHub</a>"""
        )
        msg.exec_()

    def closeEvent(self, event):
        """Autogenerated stub documentation removed for clarity."""
        # Check all tabs for unsaved changes
        for index in range(self.tab_widget.count()):
            editor = self.tab_widget.widget(index)
            if isinstance(editor, QtWidgets.QTextEdit) and editor is not self.plus_tab_dummy:
                if getattr(editor, "is_modified", False):
                    self.tab_widget.setCurrentIndex(index)
                    reply = QtWidgets.QMessageBox.question(
                        self,
                        "Save Changes?",
                        "Do you want to save before closing the editor?",
                        QtWidgets.QMessageBox.Yes
                        | QtWidgets.QMessageBox.No
                        | QtWidgets.QMessageBox.Cancel,
                        QtWidgets.QMessageBox.Cancel,
                    )
                    if reply == QtWidgets.QMessageBox.Yes:
                        self.save()
                        continue
                    elif reply == QtWidgets.QMessageBox.Cancel:
                        event.ignore()
                        return
        # On clean close, remove any crash-recovery file
        try:
            backup_path = self._recovery_path()
            if os.path.exists(backup_path):
                os.remove(backup_path)
        except Exception:
            pass
        event.accept()


# ------------------------------------------------------------- #
#  Launch in Nuke                                                #
# ------------------------------------------------------------- #
def show_texteditor():
    """Show or raise the global Nuke Text Editor instance."""
    global _text_editor_instance
    try:
        if _text_editor_instance and _text_editor_instance.isVisible():
            _text_editor_instance.raise_()
            _text_editor_instance.activateWindow()
            return _text_editor_instance
    except Exception:
        _text_editor_instance = None

    _text_editor_instance = TextEditorWidget()
    _text_editor_instance.show()
    return _text_editor_instance
